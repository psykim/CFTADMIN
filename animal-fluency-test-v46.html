<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>동물 범주 언어유창성검사 V46 - CFTSCORING 알고리즘 100% 일치 구현</title>
    <!-- favicon.ico 404 오류 방지 -->
    <link rel="icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" type="image/x-icon">
    <!-- Version 6.0 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Apple SD Gothic Neo', 'Malgun Gothic', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
        }
        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 28px;
        }
        .page {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }
        .page.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .instructions-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .content {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 800px;
            margin: 0 auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .content h2 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 24px;
        }
        .instruction-card {
            background: #f8f9fa;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        .instruction-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .test-content {
            background: transparent;
            padding: 30px;
            border-radius: 8px;
            display: block !important;
        }
        .timer-display {
            text-align: center;
            font-size: 48px;
            font-weight: bold;
            color: #e74c3c;
            margin: 20px 0;
        }
        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }
        .btn {
            padding: 12px 30px;
            font-size: 18px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        .btn-primary:hover {
            background-color: #2980b9;
        }
        .btn-success {
            background-color: #2ecc71;
            color: white;
        }
        .btn-success:hover {
            background-color: #27ae60;
        }
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .input-section {
            margin: 20px 0;
            text-align: center;
        }
        #manualInput {
            padding: 10px;
            font-size: 18px;
            width: 300px;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin-right: 10px;
        }
        .results-section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .animal-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            min-height: 50px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .animal-item {
            background: #3498db;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 16px;
        }
        .animal-item.duplicate {
            background: #e74c3c;
        }
        .stats {
            margin-top: 30px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .stat-value {
            font-weight: bold;
            color: #2c3e50;
        }
        .recording-indicator {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            color: #e74c3c;
            font-weight: bold;
        }
        .recording-indicator.active {
            display: flex;
        }
        .rec-dot {
            width: 12px;
            height: 12px;
            background-color: #e74c3c;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        .prev-btn {
            background-color: #95a5a6;
            color: white;
        }
        .prev-btn:hover {
            background-color: #7f8c8d;
        }
        .next-btn {
            background-color: #2ecc71;
            color: white;
        }
        .next-btn:hover {
            background-color: #27ae60;
        }
        .voice-guide-btn {
            background-color: #f39c12;
            color: white;
        }
        .voice-guide-btn:hover {
            background-color: #e67e22;
        }
        .download-btn {
            background-color: #9b59b6;
            color: white;
            margin-top: 20px;
        }
        .download-btn:hover {
            background-color: #8e44ad;
        }
        .user-info-form {
            max-width: 600px;
            margin: 30px auto;
        }
        .form-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .form-group {
            flex: 1;
            min-width: 180px;
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: white;
        }
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #3498db;
        }
        .form-group small {
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
            margin-top: 5px;
            display: block;
        }
        .gender-group {
            width: 100%;
            flex: none;
        }
        .radio-group {
            display: flex;
            gap: 30px;
            margin-top: 10px;
        }
        .radio-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: normal;
            margin: 0;
        }
        .radio-label input[type="radio"] {
            width: auto;
            margin-right: 8px;
            transform: scale(1.2);
        }
        .radio-label span {
            font-size: 16px;
            color: white;
        }
        .ready-box {
            text-align: center;
            color: white;
            position: relative;
            z-index: 9999;
            display: none !important; /* 동그란 시작 버튼 화면 완전 제거 */
        }
        .ready-check {
            font-size: 18px;
            margin-top: 30px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 300;
            letter-spacing: 0.5px;
        }
        .ready-check p {
            margin: 0;
            color: rgba(255, 255, 255, 0.8);
        }
        .start-button {
            background: 
                radial-gradient(ellipse at center, #16a34a 0%, #22c55e 40%, #4ade80 100%);
            color: white;
            border: none;
            width: 160px;
            height: 160px;
            font-size: 26px;
            font-weight: 700;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 10px 25px rgba(0, 0, 0, 0.3),
                0 0 0 8px rgba(34, 197, 94, 0.1),
                inset 0 -8px 16px rgba(255, 255, 255, 0.2),
                inset 0 8px 16px rgba(0, 0, 0, 0.3),
                inset 0 0 40px rgba(0, 0, 0, 0.2);
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            display: inline-block;
            margin-bottom: 0;
            text-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.5),
                0 -1px 0 rgba(255, 255, 255, 0.1);
            z-index: 10000;
        }
        .start-button::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            right: 10%;
            bottom: 10%;
            border-radius: 50%;
            background: 
                radial-gradient(ellipse at center bottom, rgba(0, 0, 0, 0.2) 0%, transparent 70%);
            opacity: 0.8;
        }
        .start-button::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: 
                inset 0 -3px 8px rgba(255, 255, 255, 0.3),
                inset 0 3px 8px rgba(0, 0, 0, 0.3);
            opacity: 0.5;
        }
        .start-button span {
            position: relative;
            z-index: 1;
        }
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.4),
                0 0 0 10px rgba(34, 197, 94, 0.15),
                inset 0 -8px 16px rgba(255, 255, 255, 0.25),
                inset 0 8px 16px rgba(0, 0, 0, 0.25),
                inset 0 0 40px rgba(0, 0, 0, 0.15);
            background: 
                radial-gradient(ellipse at center, #1fb85a 0%, #2ed068 40%, #52e88e 100%);
        }
        .start-button:active {
            transform: translateY(2px);
            box-shadow: 
                0 5px 15px rgba(0, 0, 0, 0.3),
                0 0 0 8px rgba(34, 197, 94, 0.1),
                inset 0 -4px 8px rgba(255, 255, 255, 0.15),
                inset 0 10px 20px rgba(0, 0, 0, 0.4),
                inset 0 0 50px rgba(0, 0, 0, 0.3);
            background: 
                radial-gradient(ellipse at center, #148f42 0%, #1fb34e 40%, #3ec670 100%);
        }
        .voice-guide-box {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: rgba(52, 73, 94, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            max-width: 300px;
            transform: translateY(100px);
            transition: transform 0.3s;
            z-index: 1000;
            opacity: 0;
        }
        .voice-guide-box.active {
            transform: translateY(0);
            opacity: 1;
        }
        .no-setup-warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        .interval-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .interval-stat {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .interval-stat h5 {
            margin: 0 0 5px 0;
            color: #666;
            font-size: 14px;
        }
        .interval-stat .count {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        /* 검사 시작 화면 효과 */
        .test-start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 2000;
        }
        .test-start-overlay.active {
            display: flex;
        }
        .mic-icon {
            width: 120px;
            height: 120px;
            background: #e74c3c;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            animation: pulse 1.5s infinite;
        }
        .mic-icon svg {
            width: 60px;
            height: 60px;
            fill: white;
        }
        .test-start-text {
            font-size: 48px;
            color: white;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            animation: fadeInUp 0.5s ease-out forwards;
            animation-delay: 0.3s;
        }
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* 테스트 화면 스타일 */
        .test-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1500;
        }
        .test-screen.active {
            display: flex;
        }
        .test-mic-container {
            margin-bottom: 40px;
            text-align: center;
        }
        .test-mic-icon {
            width: 140px;
            height: 140px;
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 40px;
            transition: all 0.3s ease;
            box-shadow: 
                0 8px 30px rgba(0,0,0,0.3),
                inset 0 2px 4px rgba(255,255,255,0.1),
                inset 0 -4px 8px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        .test-mic-icon::before {
            content: '';
            position: absolute;
            top: 10%;
            left: 10%;
            width: 80%;
            height: 80%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 50%);
            border-radius: 50%;
            opacity: 0.8;
        }
        .test-mic-icon::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: transparent;
            box-shadow: inset 0 0 0 2px rgba(255,255,255,0.1);
        }
        .test-mic-icon.active {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            box-shadow: 
                0 0 50px rgba(239, 68, 68, 0.6),
                0 8px 30px rgba(0,0,0,0.4),
                inset 0 2px 4px rgba(255,255,255,0.2),
                inset 0 -4px 8px rgba(0,0,0,0.3);
        }
        .test-mic-icon.active::before {
            animation: shimmer 2s ease-in-out infinite;
        }
        @keyframes shimmer {
            0%, 100% { opacity: 0.8; transform: translateX(0) translateY(0); }
            50% { opacity: 1; transform: translateX(10px) translateY(10px); }
        }
        .test-mic-icon svg {
            width: 70px;
            height: 70px;
            fill: white;
            z-index: 1;
            position: relative;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        .test-mic-icon.active svg {
            animation: mic-pulse 1.5s ease-in-out infinite;
        }
        @keyframes mic-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .response-display {
            width: 90%;
            max-width: 600px;
            height: 200px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        .response-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .response-item {
            background: rgba(33, 150, 243, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 16px;
            animation: fadeIn 0.3s ease-in;
            border: 1px solid rgba(33, 150, 243, 0.3);
        }
    </style>
    <!-- CFTSCORING 동물 데이터베이스 로드 -->
    <script src="CFTSCORING/animal-database.js"></script>
    <script src="CFTSCORING/animal-variants.js"></script>
</head>
<body>
    <!-- 오버레이 요소들 -->
    <div id="analyzing-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; align-items: center; justify-content: center;">
        <div style="text-align: center; color: white;">
            <div style="font-size: 24px; margin-bottom: 20px;">분석 중...</div>
            <div style="width: 50px; height: 50px; border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto;"></div>
        </div>
    </div>

    <div id="setupWarning" class="no-setup-warning" style="display: none;">
        <h3>⚠️ 하드웨어 설정이 필요합니다</h3>
        <p>음성 기반 검사를 위해 먼저 하드웨어 설정을 완료해주세요.</p>
        <button class="btn btn-primary" onclick="goToSetup()">하드웨어 설정하기</button>
    </div>

    <div id="browserWarning" class="no-setup-warning" style="display: none; background: #ffebee; border-color: #ef5350;">
        <h3>⚠️ 브라우저 호환성 안내</h3>
        <p>이 검사는 <strong>Chrome 브라우저</strong>에서 가장 잘 작동합니다.</p>
        <p style="margin-top: 10px; font-size: 14px;">
            현재 브라우저에서는 음성인식이 제한적이거나 마이크 권한 요청이 반복될 수 있습니다.<br>
            <strong>Chrome 브라우저</strong>를 사용하시면 더 원활한 검사가 가능합니다.
        </p>
        <div style="margin-top: 15px;">
            <button class="btn btn-primary" onclick="continueDespiteBrowser()">그래도 계속하기</button>
            <!-- Chrome 다운로드 링크 제거 (외부 참조 최소화) -->
        </div>
    </div>

    <div class="container">
        <!-- User Information Page -->
        <div class="page active" id="userInfoPage">
            <div class="content">
                <h2>참가자 정보 입력</h2>
                
                <div class="user-info-form">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="participantId">참가자 ID</label>
                            <input type="text" id="participantId" placeholder="예: TEST001" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="userAge">연령</label>
                            <input type="number" id="userAge" min="1" max="120" placeholder="나이를 입력하세요" required>
                        </div>
                        
                        <div class="form-group">
                            <label for="userEducation">교육년수</label>
                            <input type="number" id="userEducation" min="0" max="30" placeholder="총 교육년수" required>
                            <small>초등 6년 + 중학 3년 + 고등 3년 + 대학 4년 등</small>
                        </div>
                    </div>
                    
                    <div class="form-row">
                        <div class="form-group gender-group">
                            <label>성별</label>
                            <div class="radio-group">
                                <label class="radio-label">
                                    <input type="radio" name="gender" value="남" id="genderMale" required>
                                    <span>남성</span>
                                </label>
                                <label class="radio-label">
                                    <input type="radio" name="gender" value="여" id="genderFemale" required>
                                    <span>여성</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="navigation">
                    <button class="btn next-btn" id="userInfoNextBtn" style="margin-left: auto;">검사 시작</button>
                </div>
            </div>
        </div>

        <!-- Test Page -->
        <div class="page" id="testPage">
            <div class="test-content">
                <!-- 검사 진행 텍스트와 타이머 숫자 제거 -->
                
                <div class="timer-display" id="timer" style="display: none;">60</div>
                
                <div class="ready-box" id="readyBox">
                    <button class="start-button" id="manualStartBtn" style="display: block !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 99999 !important;"><span>시작하기</span></button>
                    <div class="ready-check" id="readyCheckMessage">
                        <p>조용한 장소에서 검사를 시작하세요</p>
                    </div>
                    <div id="audioPermissionNotice" style="display: none; margin-top: 30px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                        <p style="margin: 0; color: white; opacity: 0.8; font-size: 16px;">🔊 음성 안내를 시작하려면 화면을 클릭하세요</p>
                    </div>
                </div>

                <div class="control-buttons">
                    <button class="btn btn-success" id="startBtn" style="display: none;">시작</button>
                    <button class="btn btn-danger" id="stopBtn" style="display: none;">중지</button>
                    <button class="btn btn-primary" id="resetBtn" style="display: none;">다시 시작</button>
                </div>

                <div class="recording-indicator" id="recordingIndicator">
                    <div class="rec-dot"></div>
                    <span>음성 인식 중...</span>
                </div>

                <!-- 키보드 입력 섹션 제거 -->
                <!--
                <div class="input-section">
                    <input type="text" id="manualInput" placeholder="키보드로 입력 (Enter로 추가)" disabled>
                    <button class="btn btn-primary" id="addBtn" disabled>추가</button>
                </div>
                -->
            </div>

            <!-- 결과 섹션은 검사 시작 후에만 표시 -->
            <div class="results-section" id="resultsSection" style="display: none;">
                <h3>입력된 동물 목록</h3>
                <div class="animal-list" id="animalList"></div>
                
                <div class="stats" id="stats" style="display: none;">
                    <h3>검사 결과</h3>
                    
                    <div class="interval-stats" id="intervalStats"></div>
                    
                    <div class="stat-item">
                        <span class="stat-label">총 응답 수:</span>
                        <span class="stat-value" id="totalCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">유효 응답 수 (중복 제외):</span>
                        <span class="stat-value" id="uniqueCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">중복 응답 수:</span>
                        <span class="stat-value" id="duplicateCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">소요 시간:</span>
                        <span class="stat-value" id="elapsedTime">0초</span>
                    </div>
                    <button class="btn download-btn" id="downloadBtn">결과 다운로드</button>
                </div>
            </div>

            <!-- 이전 단계 버튼 제거 - 첫 페이지가 없으므로 필요 없음 -->
            <!-- <div class="navigation">
                <button class="btn prev-btn" id="testPrevBtn">이전 단계</button>
                <div></div>
            </div> -->
        </div>
    </div>

    <div class="voice-guide-box" id="voiceGuideBox">
        <div id="voiceGuideText"></div>
    </div>

    <!-- 검사 시작 오버레이 -->
    <div class="test-start-overlay" id="testStartOverlay">
        <div class="mic-icon">
            <svg viewBox="0 0 24 24">
                <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
            </svg>
        </div>
        <div class="test-start-text">검사 시작</div>
    </div>

    <!-- 테스트 화면 -->
    <div class="test-screen" id="testScreen">
        <div class="test-mic-container">
            <div class="test-mic-icon" id="testMicIcon">
                <svg viewBox="0 0 24 24">
                    <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
                </svg>
            </div>
        </div>
        <div class="response-display" id="responseDisplay">
            <div class="response-list" id="responseList"></div>
        </div>
    </div>

    <script>
        // 간단한 테스트 함수
        function testClick() {
            console.log('버튼 클릭 테스트 성공!');
            alert('버튼이 정상적으로 작동합니다!');
        }
        
        // 페이지 로드 즉시 콘솔에 메시지 출력
        console.log('V6 페이지 로드됨 - 시간:', new Date().toLocaleTimeString());
        console.log('testClick 함수 존재 여부:', typeof testClick);
        
        // 디버깅: 요소 상태 확인
        window.addEventListener('DOMContentLoaded', () => {
            const readyBox = document.getElementById('readyBox');
            const testContent = document.querySelector('.test-content');
            const testPage = document.getElementById('testPage');
            const manualStartBtn = document.getElementById('manualStartBtn');
            
            console.log('=== 시작 버튼 디버깅 ===');
            console.log('readyBox:', readyBox);
            console.log('readyBox display:', readyBox ? window.getComputedStyle(readyBox).display : 'null');
            console.log('testContent:', testContent);
            console.log('testContent display:', testContent ? window.getComputedStyle(testContent).display : 'null');
            console.log('testPage:', testPage);
            console.log('testPage display:', testPage ? window.getComputedStyle(testPage).display : 'null');
            console.log('manualStartBtn:', manualStartBtn);
            console.log('manualStartBtn display:', manualStartBtn ? window.getComputedStyle(manualStartBtn).display : 'null');
            console.log('======================');
        });
        
        // 페이지 로드 즉시 실행 - 디버깅 완료됨
        
        // 범주 정의 (CFTSCORING에서 그대로 가져옴)
        const CATEGORIES = {
            // 생물학적 분류
            MAMMAL: '포유류',
            BIRD: '조류',
            REPTILE: '파충류',
            AMPHIBIAN: '양서류',
            FISH: '어류',
            INSECT: '곤충',
            MOLLUSK: '연체동물',
            CRUSTACEAN: '갑각류',
            
            // 서식지별 분류
            MARINE: '해양동물',
            FRESHWATER: '담수동물',
            
            // 인간과의 관계
            DOMESTIC: '가축',
            PET: '애완동물',
            WILD: '야생동물',
            
            // 문화적 분류
            ZODIAC: '12간지',
            MYTHOLOGY: '신화/상상의 동물',
            PREHISTORIC: '선사시대 동물'
        };

        // CFTSCORING의 동물 데이터베이스가 외부 파일에서 로드됨
        // ANIMAL_CATEGORIES와 variantToBase는 animal-database.js와 animal-variants.js에서 정의됨
        
        // 동물 변형 사전 (CFTSCORING에서 가져옴)
        const ANIMAL_VARIANTS = {
            '개': ['개', '강아지', '멍멍이', '개새끼', '암캐', '수캐', '견', '똥개', '누렁이', '바둑이', '백구'],
            '고양이': ['고양이', '냥이', '야옹이', '고냥이', '암고양이', '수고양이', '새끼고양이', '아기고양이', '냥냥이'],
            '소': ['소', '송아지', '암소', '수소', '황소', '소새끼', '암쇠', '수쇠', '멍에소', '누렁소', '얼룩소', '한우', '젖소'],
            '돼지': ['돼지', '새끼돼지', '아기돼지', '암퇘지', '수퇘지', '멧돼지', '돝', '저', '꿀꿀이', '돼지새끼'],
            '닭': ['닭', '병아리', '암탉', '수탉', '장닭', '씨암탉', '씨수탉', '닭새끼', '꼬꼬', '꼬끼오'],
            '말': ['말', '망아지', '암말', '수말', '조랑말', '말새끼', '준마', '마', '천리마', '경주마'],
            '토끼': ['토끼', '산토끼', '집토끼', '새끼토끼', '아기토끼', '암토끼', '수토끼', '토끼새끼', '토깽이'],
            '쥐': ['쥐', '생쥐', '집쥐', '들쥐', '새끼쥐', '아기쥐', '암쥐', '수쥐', '쥐새끼', '찍찍이', '시궁쥐'],
            '호랑이': ['호랑이', '새끼호랑이', '암호랑이', '수호랑이', '호랑이새끼', '범', '백호'],
            '사자': ['사자', '새끼사자', '암사자', '수사자', '사자새끼', '라이온']
        };
        
        // 동물 이름인지 확인하는 함수 (CFTSCORING과 동일)
        function isAnimalName(word) {
            if (!word || typeof word !== 'string') return false;
            
            // normalizeAnimalName을 사용하여 확인
            const normalized = normalizeAnimalName(word);
            return normalized !== null;
        }
        
        // 동물 이름 정규화 함수 (CFTSCORING과 동일)
        function normalizeAnimalName(animalName) {
            if (!animalName || typeof animalName !== 'string') return null;
            
            // variantToBase 매핑이 있으면 사용
            if (typeof variantToBase !== 'undefined' && variantToBase[animalName]) {
                return variantToBase[animalName];
            }
            
            // 직접 ANIMAL_CATEGORIES에 있으면 그대로 반환
            if (typeof ANIMAL_CATEGORIES !== 'undefined' && ANIMAL_CATEGORIES[animalName]) {
                return animalName;
            }
            
            return null;
        }
        
        // 기본 동물 이름 가져오기 (변형을 기본형으로 변환)
        function getBaseAnimalName(word) {
            const normalized = normalizeAnimalName(word);
            return normalized || word;
        }
        
        // 전역 변수
        let animals = [];
        let uniqueAnimals = new Set();
        let startTime = null;
        let endTime = null;
        let timerInterval = null;
        let timeRemaining = 60;
        let recognition = null;
        let isRecognizing = false;
        let currentStep = 1;
        let hardwareSettings = null;
        let microphonePermissionGranted = false;
        let practiceItems = [];
        let isPracticePhase = false;
        let practiceRetryCount = 0; // 연습 재시도 횟수 추가
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let animationId = null;
        let mediaStream = null; // 마이크 스트림 유지
        
        // 사용자 정보 저장
        let userInfo = {
            participantId: '',
            age: '',
            gender: '',
            education: ''
        };

        // ElevenLabs 관련 변수
        let elevenLabsApiKey = null; // 기본값 제거 (하드웨어 설정에서만 로드)
        let elevenLabsVoiceId = null; // 기본값 제거
        let elevenLabsConnected = false; // 기본값 false로 변경
        let audioQueue = [];
        let isPlaying = false;

        // 시작 버튼 클릭 핸들러
        let isStartClicked = false;
        
        window.handleStartClick = function() {
            if (isStartClicked) {
                console.log('이미 시작됨 - 중복 호출 방지');
                return;
            }
            isStartClicked = true;
            
            console.log('handleStartClick 호출됨');
            console.log('DOM 요소 상태:', {
                voiceGuideBox: voiceGuideBox,
                voiceGuideText: voiceGuideText,
                readyBox: readyBox
            });
            
            // DOM 요소가 초기화되지 않았다면 초기화
            if (!voiceGuideBox || !voiceGuideText) {
                console.log('DOM 요소가 null입니다. 초기화 시도...');
                initializeDOMElements();
            }
            
            const manualStartBtn = document.getElementById('manualStartBtn');
            const audioPermissionNotice = document.getElementById('audioPermissionNotice');
            const readyBoxElement = document.getElementById('readyBox');
            
            // 시작 버튼과 readyBox를 즉시 숨김
            if (manualStartBtn) {
                manualStartBtn.style.display = 'none';
                console.log('시작 버튼 숨김');
            }
            
            if (readyBoxElement) {
                readyBoxElement.style.display = 'none';
                console.log('readyBox 숨김');
            }
            
            // '조용한 장소에서' 메시지도 숨김
            const readyCheckMessage = document.getElementById('readyCheckMessage');
            if (readyCheckMessage) {
                readyCheckMessage.style.display = 'none';
                console.log('readyCheckMessage 숨김');
            }
            
            // testScreen 표시 (비활성화된 마이크 아이콘 포함)
            if (testScreen) {
                testScreen.classList.add('active');
                testScreen.style.display = 'flex';
                console.log('testScreen 표시됨');
            }
            
            // 마이크 아이콘은 비활성 상태로 표시
            if (testMicIcon) {
                testMicIcon.classList.remove('active');
                console.log('마이크 아이콘 비활성 상태');
            }
            
            try {
                // 음성 안내 시작
                startInstructions();
            } catch (error) {
                console.error('startInstructions 실행 중 오류:', error);
                alert('시작 중 오류가 발생했습니다. 콘솔을 확인해주세요.');
            }
        }

        let isInstructionsStarted = false;
        
        // 음성 안내 시작 함수
        function startInstructions() {
            if (isInstructionsStarted) {
                console.log('startInstructions 이미 시작됨 - 중복 호출 방지');
                return;
            }
            isInstructionsStarted = true;
            
            console.log('startInstructions 호출됨');
            
            // 시작 버튼과 ready box 숨기기
            if (readyBox) readyBox.style.display = 'none';
            
            // '조용한 장소에서' 메시지도 숨김
            const readyCheck = document.getElementById('readyCheckMessage');
            if (readyCheck) readyCheck.style.display = 'none';
            
            // 첫 번째 단계: 연습 안내
            speak("지금부터, 간단한 검사를 시작하겠습니다.", () => {
                setTimeout(() => {
                    speak("먼저, 연습부터 해보겠습니다.", () => {
                        setTimeout(() => {
                            speak("제가 '옷' 종류라고 하면, 옷에 속하는 것들의 이름을 말씀해 보십시오.", () => {
                                setTimeout(() => {
                                    speak("예를 들어, 셔츠, 바지, 모자, 그 외 무엇이든지 상관없습니다.", () => {
                                        setTimeout(() => {
                                            speak("옷 종류에 속하는 것 중에, 또 다른 것들도 있죠.", () => {
                                                speak("삐 소리가 나고 마이크에 불이 들어오면, 옷종류에 속하는 다른 것들을 제가 그만할 때까지 최대한 많이 말씀해 보세요.", () => {
                                                    console.log('연습 안내 완료 - 삐 소리 준비');
                                                    setTimeout(() => {
                                                        console.log('연습 모드 시작');
                                                        isPracticePhase = true;
                                                        practiceItems = [];
                                                        practiceRetryCount = 0; // 재시도 횟수 초기화
                                                        if (responseList) responseList.innerHTML = '';
                                                        
                                                        // 1초 삐 소리
                                                        playBeep(880, 1000).then(() => {
                                                            console.log('삐 소리 완료 - 마이크 활성화');
                                                            
                                                            // 마이크 아이콘 활성화
                                                            if (testMicIcon) {
                                                                testMicIcon.classList.add('active');
                                                            }
                                                            
                                                            // testScreen 표시
                                                            if (testScreen) {
                                                                testScreen.classList.add('active');
                                                                testScreen.style.display = 'flex';
                                                            }
                                                            
                                                            // 오디오 시각화 시작
                                                            startAudioVisualization();
                                                            
                                                            // 마이크 권한 요청 및 음성인식 시작
                                                            setTimeout(() => {
                                                                // 음성인식 초기화 확인
                                                                if (!recognition) {
                                                                    console.log('연습 시작 전 음성인식 초기화');
                                                                    initializeSpeechRecognition();
                                                                }
                                                                
                                                                // 음성인식 시작
                                                                console.log('연습 모드에서 음성인식 시작 준비');
                                                                isPracticePhase = true;  // 연습 모드 플래그 설정
                                                                isRecognizing = true;  // 음성인식 플래그도 true로 설정
                                                                startSpeechRecognition();
                                                                console.log('연습 음성인식 시작 함수 호출됨');
                                                            }, 500)  // 0.5초 대기
                                                            
                                                            // 10초 연습 시간
                                                            setTimeout(() => {
                                                                console.log('10초 연습 시간 종료');
                                                                console.log('연습 항목 개수:', practiceItems.length);
                                                                console.log('연습 항목:', practiceItems);
                                                                
                                                                // 연습 모드 종료
                                                                isPracticePhase = false;
                                                                // 음성인식은 계속 유지 (본 검사를 위해)
                                                                // isRecognizing = false; // 주석 처리 - 음성인식 유지
                                                                
                                                                // 마이크 아이콘 비활성화
                                                                if (testMicIcon) {
                                                                    testMicIcon.classList.remove('active');
                                                                }
                                                                
                                                                // 오디오 시각화 중지
                                                                stopAudioVisualization();
                                                                
                                                                // 응답이 있었는지 확인하고 본 검사로 진행
                                                                if (practiceItems.length === 0 && practiceRetryCount < 1) {
                                                                    console.log('연습 응답 없음 - 재시도 안내');
                                                                    practiceRetryCount++; // 재시도 횟수 증가
                                                                    speak("아무 말씀도 들리지 않았습니다. 다시 한번 연습해보겠습니다.", () => {
                                                                        setTimeout(() => {
                                                                            speak("제가 옷 종류라고 말하면, 삐 소리가 나고 마이크에 불이 들어올 때 옷에 속하는 것들을 말씀해주세요.", () => {
                                                                                setTimeout(() => {
                                                                                    // 연습 재시작
                                                                                    practiceItems = [];
                                                                                    if (responseList) responseList.innerHTML = '';
                                                                                    
                                                                                    // 1초 삐 소리
                                                                                    playBeep(880, 1000).then(() => {
                                                                                        // 마이크 활성화 표시
                                                                                        if (testMicIcon) testMicIcon.classList.add('active');
                                                                                        
                                                                                        // 오디오 시각화 시작
                                                                                        startAudioVisualization();
                                                                                        
                                                                                        console.log('연습 재시도 시작 - 10초 대기');
                                                                                        setTimeout(() => {
                                                                                            console.log('연습 재시도 종료');
                                                                                            isPracticePhase = false;
                                                                                            
                                                                                            // 마이크 비활성화
                                                                                            if (testMicIcon) testMicIcon.classList.remove('active');
                                                                                            
                                                                                            // 오디오 시각화 중지
                                                                                            stopAudioVisualization();
                                                                                            
                                                                                            // 두 번째 연습에서도 응답이 없으면 본검사로 진행
                                                                                            if (practiceItems.length === 0) {
                                                                                                console.log('연습 재시도에도 응답 없음 - 본검사로 진행');
                                                                                                speak("본 검사로 넘어가겠습니다.", () => {
                                                                                                    proceedToMainTest();
                                                                                                });
                                                                                            } else {
                                                                                                speak("잘하셨습니다. 그렇게 하시면 됩니다.", () => {
                                                                                                    proceedToMainTest();
                                                                                                });
                                                                                            }
                                                                                        }, 10000); // 10초
                                                                                    });
                                                                                }, 1000);
                                                                            });
                                                                        }, 800);
                                                                    });
                                                                } else if (practiceItems.length === 0 && practiceRetryCount >= 1) {
                                                                    // 재시도 횟수를 초과한 경우 바로 본검사로 진행
                                                                    console.log('연습 재시도 횟수 초과 - 본검사로 진행');
                                                                    speak("본 검사로 넘어가겠습니다.", () => {
                                                                        proceedToMainTest();
                                                                    });
                                                                } else {
                                                                    speak("잘하셨습니다. 그렇게 하시면 됩니다.", () => {
                                                                        proceedToMainTest();
                                                                    });
                                                                }
                                                            }, 10000); // 10초
                                                        });
                                                    }, 1500);
                                                });
                                            });
                                        }, 800);
                                    });
                                }, 800);
                            });
                        }, 800);
                    });
                }, 800);
            });
        }

        // DOM 요소 (초기에는 null로 설정)
        let pages = null;
        let timer = null;
        let startBtn = null;
        let stopBtn = null;
        let resetBtn = null;
        let animalList = null;
        let stats = null;
        let recordingIndicator = null;
        let downloadBtn = null;
        let voiceGuideBox = null;
        let voiceGuideText = null;
        let readyBox = null;
        let setupWarning = null;
        let testStartOverlay = null;
        let testScreen = null;
        let responseList = null;
        let resultsSection = null;
        let testMicIcon = null;
        
        // DOM 요소 초기화 함수
        function initializeDOMElements() {
            pages = {
                test: document.getElementById('testPage'),
                userInfo: document.getElementById('userInfoPage')
            };
            
            // User info page elements
            const userInfoPrevBtn = document.getElementById('userInfoPrevBtn');
            const userInfoNextBtn = document.getElementById('userInfoNextBtn');
            const participantIdInput = document.getElementById('participantId');
            const userAgeInput = document.getElementById('userAge');
            const userGenderSelect = document.getElementById('userGender');
            const userEducationInput = document.getElementById('userEducation');
            
            timer = document.getElementById('timer');
            startBtn = document.getElementById('startBtn');
            stopBtn = document.getElementById('stopBtn');
            resetBtn = document.getElementById('resetBtn');
            animalList = document.getElementById('animalList');
            stats = document.getElementById('stats');
            recordingIndicator = document.getElementById('recordingIndicator');
            downloadBtn = document.getElementById('downloadBtn');
            voiceGuideBox = document.getElementById('voiceGuideBox');
            voiceGuideText = document.getElementById('voiceGuideText');
            readyBox = document.getElementById('readyBox');
            setupWarning = document.getElementById('setupWarning');
            testStartOverlay = document.getElementById('testStartOverlay');
            testScreen = document.getElementById('testScreen');
            responseList = document.getElementById('responseList');
            resultsSection = document.getElementById('resultsSection');
            testMicIcon = document.getElementById('testMicIcon');
            
            // 디버깅을 위한 로그
            console.log('DOM 요소 초기화 결과:', {
                timer: timer ? 'OK' : 'NULL',
                startBtn: startBtn ? 'OK' : 'NULL',
                stopBtn: stopBtn ? 'OK' : 'NULL',
                testScreen: testScreen ? 'OK' : 'NULL'
            });
        }

        // 하드웨어 설정 페이지로 이동
        function goToSetup() {
            // 하드웨어 설정 페이지로 이동하지 않고 경고만 표시
            alert('하드웨어 설정이 필요합니다. 음성 기능 없이 계속 진행합니다.');
            // window.location.href = 'hardware-setup.html?next=animal-fluency-test-v2.html';
        }
        
        // 브라우저 경고 무시하고 계속
        function continueDespiteBrowser() {
            document.getElementById('browserWarning').style.display = 'none';
            tryAutoVoiceStart();
        }
        
        
        
        // 음성 테스트 함수
        function testVoice() {
            console.log('=== 음성 테스트 시작 ===');
            console.log('ElevenLabs 설정:', {
                apiKey: elevenLabsApiKey ? 'Set' : 'Not set',
                voiceId: elevenLabsVoiceId,
                connected: elevenLabsConnected
            });
            console.log('하드웨어 설정:', hardwareSettings);
            
            // 1. 브라우저 기본 TTS 테스트
            const utterance = new SpeechSynthesisUtterance("브라우저 기본 음성 테스트입니다.");
            utterance.lang = 'ko-KR';
            utterance.onend = () => console.log('브라우저 TTS 완료');
            utterance.onerror = (e) => console.error('브라우저 TTS 오류:', e);
            window.speechSynthesis.speak(utterance);
            
            // 2. speak 함수 테스트
            setTimeout(() => {
                speak("이것은 통합 음성 함수 테스트입니다.", () => {
                    console.log('speak 함수 테스트 완료');
                });
            }, 2000);
        }
        
        // 음성 안내 시작 여부 추적
        let voiceIntroStarted = false;
        
        // 음성 안내 시작 함수
        function startVoiceIntroduction() {
            
            // 이미 시작된 경우 중복 실행 방지
            if (voiceIntroStarted) {
                console.log('음성 안내가 이미 시작되었습니다.');
                return;
            }
            
            voiceIntroStarted = true;
            console.log('음성 안내 시작...');
            
            // 브라우저 체크 및 안내
            const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
            const isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
            const isEdge = /Edg/.test(navigator.userAgent);
            
            if (!isChrome) {
                console.log('Chrome이 아닌 브라우저 감지:', navigator.userAgent);
            }
            
            // 즉시 시작 화면 숨기고 테스트 화면 표시
            if (readyBox) readyBox.style.display = 'none';
            
            // '조용한 장소에서' 메시지도 숨김
            const readyCheckMsg = document.getElementById('readyCheckMessage');
            if (readyCheckMsg) readyCheckMsg.style.display = 'none';
            
            // startInstructions 함수 호출로 연결 - 제거 (중복 방지)
            // startInstructions();
            
            // 마이크 아이콘은 비활성 상태로 표시
            const localTestMicIcon = document.getElementById('testMicIcon');
            if (localTestMicIcon) localTestMicIcon.classList.remove('active');
            
            // 바로 음성 안내 시작 (무음 오디오 재생 없이)
            speak("이제 검사를 시작하겠습니다.", () => {
                console.log('첫 번째 안내 완료');
                
                setTimeout(() => {
                    speak("제가, 어떤 종류를 말씀드리면, 되도록, 빨리, 그 종류에 속하는 사물들의 이름을, 모두 말씀해주세요.", () => {
                        speak("예를 들어, 제가, '옷 종류'라고 말하면, 셔츠, 넥타이, 모자 등의 이름을, 말씀하시면 됩니다.", () => {
                            speak("옷 종류에 속하는 것 중에, 또 다른 것들도 있죠.", () => {
                                speak("삐 소리가 나고 마이크에 불이 들어오면, 옷종류에 속하는 다른 것들을 제가 그만할 때까지 최대한 많이 말씀해 보세요.", () => {
                                    console.log('연습 안내 완료 - 삐 소리 준비');
                                    setTimeout(() => {
                                        console.log('연습 모드 시작');
                                        isPracticePhase = true;
                                        practiceItems = [];
                                        practiceRetryCount = 0; // 재시도 횟수 초기화
                                        if (responseList) responseList.innerHTML = '';
                                        
                                        // 1초 삐 소리
                                        playBeep(880, 1000).then(async () => {
                                            // 마이크 활성화 표시
                                            if (testMicIcon) testMicIcon.classList.add('active');
                                            
                                            // 오디오 시각화 시작 (이미 권한이 있으면 재사용)
                                            startAudioVisualization();
                                            
                                            // 삐 소리 후 짧은 대기 시간을 두고 음성인식 시작
                                            setTimeout(() => {
                                                // 음성인식 시작 (연습용)
                                                if (!recognition) {
                                                    console.log('연습용 음성인식 초기화');
                                                    initializeSpeechRecognition();
                                                }
                                                
                                                if (recognition) {
                                                    isPracticePhase = true;  // 연습 모드 플래그 설정
                                                    isRecognizing = true;  // 음성인식 플래그도 true로 설정
                                                    startSpeechRecognition();
                                                    console.log('연습용 음성인식 시작 함수 호출');
                                                } else {
                                                    console.error('음성인식 초기화 실패');
                                                }
                                            }, 500)  // 0.5초 대기
                                            
                                            // 10초 연습 시간
                                            setTimeout(() => {
                                                console.log('10초 연습 시간 종료');
                                                console.log('연습 항목 개수:', practiceItems.length);
                                                console.log('연습 항목:', practiceItems);
                                                
                                                // 연습 모드 종료
                                                isPracticePhase = false;
                                                // 음성인식은 계속 유지 (본 검사를 위해)
                                                // isRecognizing = false; // 주석 처리 - 음성인식 유지
                                                console.log('연습 종료 - 음성인식은 계속 유지');
                                                
                                                // 마이크 비활성화 표시
                                                if (testMicIcon) testMicIcon.classList.remove('active');
                                                
                                                // 오디오 시각화 중지
                                                stopAudioVisualization();
                                                
                                                // 응답이 있었는지 확인
                                                if (practiceItems.length === 0 && practiceRetryCount < 1) {
                                                    console.log('연습 응답 없음 - 재시도 안내');
                                                    practiceRetryCount++; // 재시도 횟수 증가
                                                    speak("아무 말씀도 들리지 않았습니다. 다시 한번 연습해보겠습니다.", () => {
                                                        setTimeout(() => {
                                                            speak("제가 옷 종류라고 말하면, 삐 소리가 나고 마이크에 불이 들어올 때 옷에 속하는 것들을 말씀해주세요.", () => {
                                                                setTimeout(() => {
                                                                    // 연습 재시작
                                                                    isPracticePhase = true;
                                                                    practiceItems = [];
                                                                    responseList.innerHTML = '';
                                                                    
                                                                    playBeep(880, 1000).then(() => {
                                                                        if (testMicIcon) testMicIcon.classList.add('active');
                                                                        startAudioVisualization();
                                                                        
                                                                        setTimeout(() => {
                                                                            if (recognition && !isRecognizing) {
                                                                                try {
                                                                                    recognition.start();
                                                                                    isRecognizing = true;
                                                                                    console.log('연습 재시도 - 음성인식 시작');
                                                                                } catch (e) {
                                                                                    console.log('음성인식 시작 실패:', e);
                                                                                }
                                                                            }
                                                                        }, 500);
                                                                        
                                                                        // 10초 후 다시 체크
                                                                        setTimeout(() => {
                                                                            isPracticePhase = false;
                                                                            isRecognizing = false;
                                                                            if (testMicIcon) testMicIcon.classList.remove('active');
                                                                            stopAudioVisualization();
                                                                            
                                                                            // 두 번째 시도에서도 응답이 없으면 그냥 진행
                                                                            if (practiceItems.length === 0) {
                                                                                speak("옷의 종류를 말씀하셔야 합니다. 예를 들어 셔츠, 바지, 모자 같은 것들입니다. 본 검사로 넘어가겠습니다.", () => {
                                                                                    proceedToMainTest();
                                                                                });
                                                                            } else {
                                                                                speak("잘하셨습니다. 그렇게 하시면 됩니다.", () => {
                                                                                    proceedToMainTest();
                                                                                });
                                                                            }
                                                                        }, 10000);
                                                                    });
                                                                }, 1000);
                                                            });
                                                        }, 800);
                                                    });
                                                } else if (practiceItems.length === 0 && practiceRetryCount >= 1) {
                                                    // 재시도 횟수를 초과한 경우 바로 본검사로 진행
                                                    console.log('연습 재시도 횟수 초과 - 본검사로 진행');
                                                    speak("본 검사로 넘어가겠습니다.", () => {
                                                        proceedToMainTest();
                                                    });
                                                } else {
                                                    speak("잘하셨습니다. 그렇게 하시면 됩니다.", () => {
                                                        proceedToMainTest();
                                                    });
                                                }
                                            }, 10000); // 10초 대기
                                        });
                                    }, 1000);
                                });
                            });
                        });
                    });
                }, 1000);
            });
        }
        
        // 본 검사 진행 함수
        function proceedToMainTest() {
            console.log('proceedToMainTest 함수 호출됨');
            setTimeout(() => {
                console.log('본시행 안내 시작');
                speak("지금부터는, 다른 종류, 즉 '동물' 종류에 속하는 것들의 이름을, 모두 말씀해보십시오.", () => {
                    setTimeout(() => {
                        speak("1분의 시간을 드리겠습니다. 1분 동안, 생각나는 동물의 이름을, 마이크가 꺼질 때까지 포기하지 마시고, 최대한 많이 말씀해 보세요.", () => {
                            setTimeout(() => {
                                speak("준비되셨습니까? 삐 소리가 나고 마이크에 불이 들어오면, 바로 시작해 주세요.", () => {
                                    console.log('모든 안내 완료 - 현재 시각:', new Date().toLocaleTimeString());
                                    
                                    // 안내 종료 후 1초 대기
                                    console.log('1초 대기 시작');
                                    setTimeout(() => {
                                        console.log('1초 대기 완료 - 본시행 시작:', new Date().toLocaleTimeString());
                                        startTest(); // 시작 함수 직접 호출
                                    }, 1000);
                                });
                            }, 800);
                        });
                    }, 800);
                });
            }, 800);
        }

        // 하드웨어 설정 불러오기
        function loadHardwareSettings() {
            const settingsStr = localStorage.getItem('hardwareSettings');
            if (settingsStr) {
                try {
                    hardwareSettings = JSON.parse(settingsStr);
                    console.log('하드웨어 설정 로드:', hardwareSettings);
                    
                    // ElevenLabs 설정 적용 (설정이 있으면 덮어쓰기)
                    if (hardwareSettings.elevenLabsApiKey) {
                        elevenLabsApiKey = hardwareSettings.elevenLabsApiKey;
                    }
                    if (hardwareSettings.elevenLabsVoiceId) {
                        elevenLabsVoiceId = hardwareSettings.elevenLabsVoiceId;
                    }
                    if (hardwareSettings.elevenLabsConnected !== undefined) {
                        elevenLabsConnected = hardwareSettings.elevenLabsConnected;
                    }
                    
                    console.log('ElevenLabs 설정:', {
                        apiKey: elevenLabsApiKey ? 'Set' : 'Not set',
                        voiceId: elevenLabsVoiceId,
                        connected: elevenLabsConnected
                    });
                    
                    // 음성 설정이 활성화되어 있는지 확인
                    if (!hardwareSettings.voiceEnabled) {
                        console.log('음성 기능이 비활성화되어 있습니다.');
                    }
                    
                    return true;
                } catch (error) {
                    console.error('하드웨어 설정 파싱 오류:', error);
                    return false;
                }
            }
            console.log('하드웨어 설정이 없습니다.');
            return false;
        }

        // 페이지 전환
        function showPage(pageId) {
            console.log('showPage 호출:', pageId);
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
                page.style.display = 'none';
            });
            const targetPage = document.getElementById(pageId);
            if (targetPage) {
                targetPage.classList.add('active');
                targetPage.style.display = 'block';
                console.log('페이지 표시 완료:', pageId);
            } else {
                console.error('페이지를 찾을 수 없음:', pageId);
            }
        }

        // 음성 안내 표시
        function showVoiceGuide(text) {
            console.log('showVoiceGuide 호출:', {
                text: text,
                voiceGuideBox: voiceGuideBox,
                voiceGuideText: voiceGuideText
            });
            
            if (!voiceGuideBox || !voiceGuideText) {
                console.error('voiceGuideBox 또는 voiceGuideText가 null입니다');
                return;
            }
            
            voiceGuideText.textContent = text;
            voiceGuideBox.classList.add('active');
        }

        function hideVoiceGuide() {
            voiceGuideBox.classList.remove('active');
        }

        // ElevenLabs TTS
        async function elevenLabsTTS(text, callback) {
            console.log('elevenLabsTTS 호출:', {
                apiKey: elevenLabsApiKey ? 'Set' : 'Not set',
                voiceId: elevenLabsVoiceId,
                text: text
            });
            
            if (!elevenLabsApiKey || !elevenLabsVoiceId) {
                console.error('ElevenLabs 설정이 누락되었습니다');
                // ElevenLabs 실패 시 기본 TTS로 폴백
                defaultTTS(text, callback);
                return;
            }

            audioQueue.push({ text, callback });
            if (!isPlaying) {
                playNextInQueue();
            }
        }

        async function playNextInQueue() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }

            isPlaying = true;
            const { text, callback } = audioQueue.shift();

            try {
                // API 키가 없으면 바로 실패 처리
                if (!elevenLabsApiKey || !elevenLabsVoiceId) {
                    throw new Error('ElevenLabs API 키 또는 Voice ID가 설정되지 않았습니다.');
                }
                
                console.log('ElevenLabs API 호출 시작:', {
                    url: `https://api.elevenlabs.io/v1/text-to-speech/${elevenLabsVoiceId}/stream`,
                    text: text
                });
                
                // ElevenLabs API 호출 비활성화 (404 오류 방지)
                throw new Error('ElevenLabs API 호출 비활성화됨');
                /* 404 오류 방지를 위해 주석 처리
                const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${elevenLabsVoiceId}/stream`, {
                    method: 'POST',
                    headers: {
                        'xi-api-key': elevenLabsApiKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model_id: "eleven_multilingual_v2",
                        voice_settings: hardwareSettings?.voiceSettings || {
                            stability: 0.85,  // 더 안정적인 발음을 위해 증가
                            similarity_boost: 0.75,
                            style: 0.3,  // 더 명확한 발음을 위해 감소
                            use_speaker_boost: true
                        }
                    })
                });

                console.log('ElevenLabs API 응답:', {
                    status: response.status,
                    ok: response.ok
                });

                if (response.ok) {
                    const audioBlob = await response.blob();
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    
                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        hideVoiceGuide();
                        
                        // 음성 안내가 끝난 후에도 음성인식을 자동으로 재시작하지 않음
                        // 삐 소리 후에만 시작하도록 함
                        
                        if (callback) callback();
                        playNextInQueue();
                    };

                    audio.onerror = () => {
                        console.error('오디오 재생 오류');
                        hideVoiceGuide();
                        if (callback) callback();
                        playNextInQueue();
                    };

                    audio.play();
                } else {
                    // API 응답 실패 시 에러 내용 확인
                    const errorText = await response.text();
                    console.error('ElevenLabs API 에러:', {
                        status: response.status,
                        error: errorText
                    });
                    // 기본 TTS로 폴백
                    hideVoiceGuide();
                    defaultTTS(text, callback);
                    playNextInQueue();
                }
                */ // 404 오류 방지를 위해 주석 처리 끝
            } catch (error) {
                console.error('ElevenLabs TTS 오류:', error);
                hideVoiceGuide();
                // 기본 TTS로 폴백
                defaultTTS(text, callback);
                playNextInQueue();
            }
        }

        // 기본 브라우저 TTS
        function defaultTTS(text, callback) {
            console.log('defaultTTS 호출:', text);
            
            if (!window.speechSynthesis) {
                console.error('브라우저가 음성 합성을 지원하지 않습니다.');
                if (callback) callback();
                return;
            }

            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'ko-KR';
            utterance.rate = hardwareSettings?.voiceSpeed || 1;
            utterance.pitch = 1;
            utterance.volume = 1;

            const voices = window.speechSynthesis.getVoices();
            console.log('사용 가능한 음성:', voices.length);
            
            const koreanVoice = voices.find(voice => voice.lang.includes('ko'));
            if (koreanVoice) {
                utterance.voice = koreanVoice;
                console.log('한국어 음성 선택:', koreanVoice.name);
            } else {
                console.log('한국어 음성을 찾을 수 없습니다.');
            }

            utterance.onstart = () => {
                console.log('음성 출력 시작');
            };
            
            utterance.onend = () => {
                console.log('음성 출력 완료');
                hideVoiceGuide();
                
                // 음성 안내가 끝난 후에도 음성인식을 자동으로 재시작하지 않음
                // 삐 소리 후에만 시작하도록 함
                
                if (callback) callback();
            };
            
            utterance.onerror = (event) => {
                console.error('음성 출력 오류:', event);
                hideVoiceGuide();
                if (callback) callback();
            };

            window.speechSynthesis.speak(utterance);
            console.log('음성 합성 요청됨');
        }

        // 음성 합성 (통합 함수)
        function speak(text, callback) {
            // 이미 같은 텍스트가 재생 중이면 중복 방지
            if (window.speechSynthesis && window.speechSynthesis.speaking) {
                console.log('음성이 이미 재생 중입니다. 중복 호출 방지:', text);
                return;
            }
            
            console.log('speak 함수 호출:', {
                text: text,
                hardwareSettings: hardwareSettings,
                voiceEnabled: hardwareSettings?.voiceEnabled !== false, // undefined일 때도 true
                elevenLabsConnected: elevenLabsConnected,
                elevenLabsApiKey: elevenLabsApiKey ? 'Set' : 'Not set'
            });
            
            // 음성 기능이 명시적으로 비활성화된 경우에만 스킵
            if (hardwareSettings && hardwareSettings.voiceEnabled === false) {
                console.log('음성 기능이 명시적으로 비활성화되어 있습니다.');
                if (callback) callback();
                return;
            }
            
            // 음성 안내 중에는 음성인식 일시 중지
            if (recognition && isRecognizing) {
                console.log('음성 안내 중 음성인식 일시 중지');
                try {
                    recognition.stop();
                } catch (e) {
                    console.log('음성인식 중지 중 오류:', e);
                }
                isRecognizing = false;
            }

            showVoiceGuide(text);

            if (elevenLabsConnected && elevenLabsApiKey && elevenLabsVoiceId) {
                console.log('ElevenLabs TTS 사용');
                elevenLabsTTS(text, callback);
            } else {
                console.log('기본 브라우저 TTS 사용');
                defaultTTS(text, callback);
            }
        }


        // 음성인식 초기화
        function initializeSpeechRecognition() {
            // 브라우저별 호환성 체크
            const SpeechRecognition = window.SpeechRecognition || 
                                    window.webkitSpeechRecognition || 
                                    window.mozSpeechRecognition || 
                                    window.msSpeechRecognition;
            
            if (!SpeechRecognition) {
                console.error('이 브라우저는 음성인식을 지원하지 않습니다.');
                alert('죄송합니다. 이 브라우저는 음성인식을 지원하지 않습니다.\n\nChrome 브라우저 사용을 권장합니다.');
                return false;
            }
            
            try {
                // 이미 recognition 객체가 있으면 재사용
                if (!recognition) {
                    recognition = new SpeechRecognition();
                    recognition.lang = 'ko-KR';
                    recognition.continuous = true;
                    recognition.interimResults = true;
                    recognition.maxAlternatives = 1;
                    
                    recognition.onstart = () => {
                        console.log('음성인식 시작됨');
                        isRecognizing = true;
                        
                        // 마이크 아이콘 활성화
                        const testMicIcon = document.querySelector('.test-mic-icon');
                        if (testMicIcon) {
                            testMicIcon.classList.add('active');
                            console.log('마이크 아이콘 활성화됨');
                        }
                    };

                    // 각 음성 세그먼트의 시작 시간을 저장하는 맵
                    const speechStartTimes = new Map();
                    
                    recognition.onresult = (event) => {
                        // 연습 모드이거나 본 검사가 진행 중일 때만 처리
                        if (!isPracticePhase && !isRecognizing) {
                            console.log('음성인식 결과 무시 - 연습/본시행 중이 아님');
                            return;
                        }
                        if (!isPracticePhase && timeRemaining <= 0) {
                            console.log('음성인식 결과 무시 - 시간 종료');
                            return;
                        }
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const result = event.results[i];
                            
                            // 이 결과에 대한 시작 시간이 아직 기록되지 않았다면 기록
                            if (!speechStartTimes.has(i)) {
                                const speechStartTime = Date.now() - startTime;
                                speechStartTimes.set(i, speechStartTime);
                                console.log(`음성 세그먼트 ${i} 시작 시간: ${speechStartTime}ms (${Math.floor(speechStartTime/1000)}초)`);
                            }
                            
                            if (result.isFinal) {
                                const transcript = result[0].transcript.trim();
                                const speechStartTime = speechStartTimes.get(i);
                                console.log('인식된 텍스트:', transcript, '연습모드:', isPracticePhase);
                                console.log('음성 입력 시작 시간:', speechStartTime, 'ms');
                                
                                const words = transcript.split(/[\s,，、]+/).filter(word => word.length > 0);
                                words.forEach((word, index) => {
                                    if (word.length > 0) {
                                        if (isPracticePhase) {
                                            // 연습 모드에서는 모든 단어 허용 (옷 종류)
                                            console.log('연습 항목 추가:', word);
                                            addPracticeItem(word);
                                        } else {
                                            // 본 검사에서는 모든 명사 인식 (V15 수정)
                                            // 여러 단어가 한 번에 인식된 경우, 각 단어에 약간의 시간 간격 추가
                                            const adjustedTime = speechStartTime + (index * 500);
                                            console.log('단어 추가:', word, '조정된 시간:', adjustedTime);
                                            // 음성 입력 시작 시간을 함께 전달
                                            addAnimal(word, adjustedTime);
                                        }
                                    }
                                });
                                
                                // 처리 완료된 결과의 시작 시간 삭제
                                speechStartTimes.delete(i);
                            }
                        }
                    };

                    recognition.onerror = (event) => {
                        console.error('음성인식 오류:', event.error);
                        if (event.error === 'no-speech' && isRecognizing) {
                            // no-speech 오류는 무시
                            console.log('no-speech 오류 무시');
                        } else if (event.error === 'not-allowed') {
                            console.error('마이크 권한이 없습니다.');
                            alert('마이크 권한을 허용해주세요.');
                        }
                    };

                    recognition.onend = () => {
                        console.log('음성인식 종료됨');
                        // 연습 모드이거나 본 검사가 진행 중일 때 재시작
                        if ((isPracticePhase || isRecognizing) && timeRemaining > 0) {
                            setTimeout(() => {
                                try {
                                    recognition.start();
                                    console.log('음성인식 재시작됨');
                                } catch (e) {
                                    console.error('음성인식 재시작 오류:', e);
                                }
                            }, 100);
                        }
                    };
                }
                
                return true;
            } catch (error) {
                console.error('음성인식 초기화 오류:', error);
                alert('음성인식 초기화 중 오류가 발생했습니다.\n\n' + error.message);
                return false;
            }
        }

        // 신호음 재생 함수
        function playBeep(frequency = 880, duration = 200) {
            return new Promise((resolve) => {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
                
                setTimeout(resolve, duration);
            });
        }


        // 오디오 분석 시작
        async function startAudioVisualization() {
            try {
                // 이미 스트림이 있고 활성 상태인지 확인
                if (!mediaStream || mediaStream.getTracks().every(track => track.readyState !== 'live')) {
                    console.log('새로운 마이크 스트림 요청');
                    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphonePermissionGranted = true;
                    console.log('마이크 권한 획득 완료');
                } else {
                    console.log('기존 마이크 스트림 재사용');
                }
                
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (!analyser) {
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                }
                
                if (!microphone) {
                    microphone = audioContext.createMediaStreamSource(mediaStream);
                    microphone.connect(analyser);
                }
            } catch (error) {
                console.error('오디오 시각화 초기화 오류:', error);
            }
        }


        // 오디오 시각화 중지
        function stopAudioVisualization() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // 마이크와 오디오 컨텍스트는 유지하고 시각화만 중지
            // 이렇게 하면 마이크 권한을 계속 유지할 수 있음
        }

        // 검사 시작 시각적 효과와 신호음
        function startTestCountdown(callback) {
            console.log('startTestCountdown 시작');
            
            // 마이크 권한 및 음성인식 준비 (이미 준비되지 않은 경우)
            if (!audioContext || !recognition) {
                console.log('마이크/음성인식 준비 필요');
                prepareMicrophoneAndRecognition();
            }
            
            // 테스트 화면 표시
            const testContent = document.querySelector('.test-content');
            console.log('테스트 콘텐츠 요소:', testContent);
            // testContent를 숨기지 않음 - 시작 버튼이 표시되어야 함
            
            console.log('testScreen 요소:', testScreen);
            if (testScreen) {
                testScreen.classList.add('active');
            } else {
                console.error('testScreen 요소를 찾을 수 없음');
            }
            
            if (responseList) {
                responseList.innerHTML = '';
            }
            isPracticePhase = false;
            
            // 1초의 긴 신호음
            console.log('신호음 재생 시작');
            playBeep(1000, 1000);
            console.log('신호음 재생 완료');
            
            // 마이크 활성화 표시
            if (testMicIcon) {
                testMicIcon.classList.add('active');
                console.log('마이크 아이콘 활성화');
            } else {
                console.error('testMicIcon 요소를 찾을 수 없음');
            }
            
            // 오디오 시각화 시작
            console.log('오디오 시각화 시작');
            startAudioVisualization();
            
            // 콜백 실행
            if (callback) {
                console.log('콜백 함수 실행');
                callback();
            }
        }

        // 연습 항목 추가
        function addPracticeItem(item) {
            if (!item || item.trim() === '') return;
            
            const trimmedItem = item.trim();
            practiceItems.push(trimmedItem);
            
            // 응답 표시에 추가
            const itemElement = document.createElement('div');
            itemElement.className = 'response-item';
            itemElement.textContent = trimmedItem;
            responseList.appendChild(itemElement);
        }

        // 동물 추가
        // 강화된 명사 필터링 함수
        function isNoun(word) {
            // 한국어 명사 판별을 위한 강화된 규칙
            // 1. 1글자 이상
            if (word.length < 1) return false;
            
            // 2. 감탄사 제외
            const interjections = ['어', '아', '오', '우', '에', '음', '흠', '아이고', '아이구', '어머', '어머나', '어이구', '에이', '아니', '아차', '앗', '와', '워', '헐', '헉', '허', '하', '히', '후', '휴', '흐'];
            if (interjections.includes(word)) return false;
            
            // 3. 부사 제외
            const adverbs = ['또', '더', '잘', '못', '안', '꼭', '곧', '즉', '바로', '아주', '매우', '너무', '정말', '참', '좀', '조금', '많이', '적게', '빨리', '천천히', '갑자기', '이미', '벌써', '아직', '가야지', '해야지', '같이', '함께', '혼자', '따로'];
            if (adverbs.includes(word)) return false;
            
            // 4. 형용사 어간 제외
            const adjectives = ['크다', '작다', '많다', '적다', '좋다', '나쁘다', '예쁘다', '밉다', '높다', '낮다', '길다', '짧다', '넓다', '좁다', '깊다', '얕다'];
            if (adjectives.includes(word)) return false;
            
            // 5. 동사/형용사 활용형 제외
            const verbEndings = ['하다', '했다', '한다', '해요', '합니다', '하는', '하고', '하지', '하며', '하니', '하면', '해서', '되다', '된다', '됐다', '있다', '없다', '같다', '겠다', '지다', '었다', '았다', '려고', '라고', '다고'];
            for (const ending of verbEndings) {
                if (word.endsWith(ending)) return false;
            }
            
            // 6. 조사 제외
            const particles = ['은', '는', '이', '가', '을', '를', '에', '에서', '에게', '한테', '의', '와', '과', '로', '으로', '부터', '까지', '도', '만', '조차', '마저', '밖에', '처럼', '보다', '마다', '라도', '이나', '나', '든지', '던지'];
            if (particles.includes(word)) return false;
            
            // 7. 숫자만으로 이루어진 것 제외
            if (/^\d+$/.test(word)) return false;
            
            // 8. 특수문자만으로 이루어진 것 제외
            if (/^[^\w가-힣]+$/.test(word)) return false;
            
            return true;
        }
        
        function addAnimal(animal, speechTimestamp) {
            if (!animal || animal.trim() === '') return;
            
            const trimmedAnimal = animal.trim();
            
            // 명사가 아닌 것은 제외 (침투로 계산하지 않음)
            if (!isNoun(trimmedAnimal)) {
                console.log(`명사가 아님 (무효 처리, 침투 아님): ${trimmedAnimal}`);
                return;
            }
            
            // speechTimestamp가 전달되면 사용하고, 없으면 현재 시간 사용
            const timestamp = speechTimestamp !== undefined ? speechTimestamp : (Date.now() - startTime);
            
            // 동물 여부 확인
            const isValidAnimal = isAnimalName(trimmedAnimal);
            const baseAnimal = getBaseAnimalName(trimmedAnimal);
            
            console.log(`단어 추가: ${trimmedAnimal}, 동물여부: ${isValidAnimal}, 기본형: ${baseAnimal}, 시간: ${timestamp}ms (${Math.floor(timestamp/1000)}초)`);
            
            animals.push({
                name: trimmedAnimal,
                timestamp: timestamp,
                isDuplicate: uniqueAnimals.has(trimmedAnimal.toLowerCase()),
                isAnimal: isValidAnimal,
                baseAnimal: baseAnimal
            });
            
            uniqueAnimals.add(trimmedAnimal.toLowerCase());
            updateAnimalList();
            
            // 테스트 화면에도 추가
            const itemElement = document.createElement('div');
            itemElement.className = 'response-item';
            itemElement.textContent = trimmedAnimal;
            responseList.appendChild(itemElement);
        }

        // 동물 목록 업데이트
        function updateAnimalList() {
            animalList.innerHTML = '';
            animals.forEach(animal => {
                const item = document.createElement('div');
                item.className = 'animal-item' + (animal.isDuplicate ? ' duplicate' : '');
                item.textContent = animal.name;
                animalList.appendChild(item);
            });
        }

        // 타이머 시작
        function startTimer() {
            console.log('startTimer 호출됨');
            if (!timer) {
                console.error('timer 요소가 null입니다');
                return;
            }
            
            // 타이머 표시
            console.log('타이머 표시 전 display:', timer.style.display);
            timer.style.display = 'block';
            console.log('타이머 표시 후 display:', timer.style.display);
            
            timerInterval = setInterval(() => {
                timeRemaining--;
                timer.textContent = timeRemaining;
                
                if (timeRemaining <= 0) {
                    stopTest();
                }
            }, 1000);
            
            console.log('타이머 시작됨');
        }

        // 음성인식 시작 (권한은 이미 hardware-setup에서 획득)
        function startSpeechRecognition() {
            console.log('startSpeechRecognition 호출됨');
            
            if (!recognition) {
                console.log('음성인식 초기화 시도');
                initializeSpeechRecognition();
            }
            
            if (!recognition) {
                console.error('음성인식을 초기화할 수 없습니다.');
                return;
            }
            
            // 음성인식이 실행 중이 아니면 시작
            try {
                console.log('음성인식 상태:', { isRecognizing, isPracticePhase });
                if (!isRecognizing) {
                    recognition.start();
                    console.log('recognition.start() 호출됨');
                } else {
                    console.log('음성인식이 이미 실행 중');
                    // 연습 모드인 경우 재시작 시도
                    if (isPracticePhase) {
                        console.log('연습 모드 - 음성인식 재시작 시도');
                        try {
                            recognition.stop();
                            setTimeout(() => {
                                recognition.start();
                                console.log('연습 모드 음성인식 재시작됨');
                            }, 100);
                        } catch (e) {
                            console.log('음성인식 재시작 중 오류:', e);
                        }
                    }
                }
                isRecognizing = true;
                if (recordingIndicator) {
                    recordingIndicator.classList.add('active');
                }
                
                // 마이크 아이콘 활성화
                if (testMicIcon) {
                    testMicIcon.classList.add('active');
                }
            } catch (e) {
                console.error('음성인식 시작 오류:', e);
                // 이미 실행 중인 경우에도 플래그 설정
                isRecognizing = true;
                recordingIndicator.classList.add('active');
                if (testMicIcon) {
                    testMicIcon.classList.add('active');
                }
            }
        }

        // 검사 시작
        function startTest() {
            console.log('startTest 함수 호출됨');
            if (readyBox) readyBox.style.display = 'none';
            
            // '조용한 장소에서' 메시지도 숨김
            const readyCheckElement = document.getElementById('readyCheckMessage');
            if (readyCheckElement) readyCheckElement.style.display = 'none';
            animals = [];
            uniqueAnimals.clear();
            startTime = Date.now();
            timeRemaining = 60;
            if (timer) {
                timer.textContent = timeRemaining;
                timer.style.display = 'block'; // 검사 시작 시 타이머 표시
            } else {
                console.error('timer 요소가 null입니다');
            }
            
            if (startBtn) {
                startBtn.style.display = 'none';
                console.log('시작 버튼 숨김');
            } else {
                console.error('startBtn이 null입니다');
            }
            
            if (stopBtn) {
                stopBtn.style.display = 'inline-block';
                console.log('중지 버튼 표시');
            } else {
                console.error('stopBtn이 null입니다');
            }
            
            if (resetBtn) {
                resetBtn.style.display = 'none';
                console.log('리셋 버튼 숨김');
            } else {
                console.error('resetBtn이 null입니다');
            }
            if (stats) stats.style.display = 'none';
            if (resultsSection) resultsSection.style.display = 'block'; // 결과 섹션 표시
            
            updateAnimalList();
            
            console.log('startTestCountdown 호출 전');
            // 신호음과 시각적 효과로 카운트다운
            startTestCountdown(() => {
                console.log('startTestCountdown 콜백 실행');
                startTimer();
                // 삐 소리 후 음성인식 시작을 위해 약간의 대기 시간 추가
                setTimeout(() => {
                    console.log('본 검사 음성인식 시작 준비');
                    if (!recognition) {
                        console.log('recognition 객체가 없어서 초기화');
                        initializeSpeechRecognition();
                    }
                    console.log('음성인식 시작 시도');
                    startSpeechRecognition();
                }, 500);  // 0.5초 대기
            });
            console.log('startTestCountdown 완료');
        }

        // 검사 중지
        function stopTest() {
            endTime = Date.now();
            clearInterval(timerInterval);
            
            if (isRecognizing) {
                isRecognizing = false;
                recordingIndicator.classList.remove('active');
                // 음성인식은 계속 실행 중으로 유지
                console.log('검사 종료 - 음성인식은 계속 유지');
            }
            
            // 테스트 화면 숨기기
            testScreen.classList.remove('active');
            document.querySelector('.test-content').style.display = 'block';
            
            // 마이크 비활성화
            testMicIcon.classList.remove('active');
            
            // 오디오 시각화 중지
            stopAudioVisualization();
            
            if (startBtn) startBtn.style.display = 'none';
            if (stopBtn) stopBtn.style.display = 'none';
            if (resetBtn) resetBtn.style.display = 'inline-block';
            
            // V21 수정: 기본 결과 표시 건너뛰고 바로 CFTSCORING 분석
            // showResults(); // 기본 통계 표시 건너뜀
            
            // 분석 중 오버레이 즉시 표시
            document.getElementById('analyzing-overlay').style.display = 'flex';
            
            speak("검사가 종료되었습니다. 수고하셨습니다. 결과를 분석하고 있습니다.", () => {
                // 바로 CFTSCORING 분석 시작
                analyzeWithCFTSCORING();
            });
        }

        // 검사 리셋
        function resetTest() {
            readyBox.style.display = 'block';
            
            // '조용한 장소에서' 메시지도 다시 표시
            const readyCheckReset = document.getElementById('readyCheckMessage');
            if (readyCheckReset) readyCheckReset.style.display = 'block';
            animals = [];
            uniqueAnimals.clear();
            timeRemaining = 60;
            timer.textContent = timeRemaining;
            timer.style.display = 'none'; // 리셋 시 타이머 숨기기
            resultsSection.style.display = 'none'; // 결과 섹션 숨기기
            
            if (startBtn) startBtn.style.display = 'inline-block';
            if (stopBtn) stopBtn.style.display = 'none';
            if (resetBtn) resetBtn.style.display = 'none';
            stats.style.display = 'none';
            
            updateAnimalList();
        }

        // 결과 표시
        function showResults() {
            const totalCount = animals.length;
            const uniqueCount = uniqueAnimals.size;
            const duplicateCount = totalCount - uniqueCount;
            const elapsedTime = Math.round((endTime - startTime) / 1000);
            
            // 15초 간격 통계 계산
            const intervals = [
                { start: 0, end: 15, count: 0 },
                { start: 15, end: 30, count: 0 },
                { start: 30, end: 45, count: 0 },
                { start: 45, end: 60, count: 0 }
            ];
            
            animals.forEach(animal => {
                const seconds = animal.timestamp / 1000;
                for (let interval of intervals) {
                    if (seconds >= interval.start && seconds < interval.end) {
                        interval.count++;
                        break;
                    }
                }
            });
            
            // 간격별 통계 표시
            const intervalStats = document.getElementById('intervalStats');
            intervalStats.innerHTML = '';
            intervals.forEach((interval, index) => {
                const div = document.createElement('div');
                div.className = 'interval-stat';
                div.innerHTML = `
                    <h5>${interval.start}-${interval.end}초</h5>
                    <div class="count">${interval.count}</div>
                `;
                intervalStats.appendChild(div);
            });
            
            document.getElementById('totalCount').textContent = totalCount;
            document.getElementById('uniqueCount').textContent = uniqueCount;
            document.getElementById('duplicateCount').textContent = duplicateCount;
            document.getElementById('elapsedTime').textContent = elapsedTime + '초';
            
            stats.style.display = 'block';
            
            // V20 수정: resultsSection도 표시해야 함
            if (resultsSection) {
                resultsSection.style.display = 'block';
                console.log('결과 섹션 표시됨');
            } else {
                console.error('resultsSection을 찾을 수 없습니다');
            }
        }

        // 결과 다운로드 (CSV 형식)
        function downloadResults() {
            const testDate = new Date();
            const intervalStats = calculateIntervalStats();
            
            // CSV BOM 추가 (한글 엑셀 호환)
            let csvContent = '\ufeff';
            
            // CSV 헤더
            csvContent += 'ID,성별,연령,학력,0-15초,15-30초,30-45초,45-60초\n';
            
            // 데이터 행 추가
            const id = testDate.toISOString().slice(0,10).replace(/-/g,'') + '_' + testDate.getHours().toString().padStart(2,'0') + testDate.getMinutes().toString().padStart(2,'0');
            const gender = '미입력';
            const age = '미입력';
            const education = '미입력';
            
            // 각 구간별 동물 목록
            const intervals = [
                intervalStats['0-15초'] || [],
                intervalStats['15-30초'] || [],
                intervalStats['30-45초'] || [],
                intervalStats['45-60초'] || []
            ];
            
            // CSV 행 생성
            csvContent += `${id},${gender},${age},${education},`;
            csvContent += intervals.map(interval => `"${interval.join(',')}"`).join(',');
            csvContent += '\n';
            
            // Blob 생성 및 다운로드
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `동물유창성검사_${testDate.toISOString().slice(0,10).replace(/-/g,'')}_${testDate.getHours().toString().padStart(2,'0')}${testDate.getMinutes().toString().padStart(2,'0')}${testDate.getSeconds().toString().padStart(2,'0')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 동물 이름 필터링 함수
        function isAnimalName(text) {
            // 기본적인 한국어 동물 이름 패턴
            const animalPatterns = [
                // 일반적인 동물 이름들
                '개', '고양이', '소', '말', '돼지', '닭', '오리', '염소', '양', '토끼',
                '사자', '호랑이', '곰', '늑대', '여우', '사슴', '노루', '멧돼지', '코끼리', '기린',
                '원숭이', '고릴라', '침팬지', '오랑우탄', '개미', '벌', '나비', '잠자리', '메뚜기',
                '뱀', '도마뱀', '악어', '거북이', '개구리', '두꺼비', '이구아나', '카멜레온',
                '독수리', '매', '까마귀', '까치', '참새', '비둘기', '제비', '두루미', '백로', '올빼미',
                '고래', '돌고래', '상어', '물개', '바다사자', '펭귄', '해마', '오징어', '문어',
                '쥐', '다람쥐', '청설모', '햄스터', '기니피그', '친칠라', '고슴도치', '두더지',
                '표범', '재규어', '치타', '하이에나', '미어캣', '수달', '너구리', '오소리',
                '캥거루', '코알라', '웜뱃', '타조', '에뮤', '플라밍고', '앵무새', '공작'
            ];
            
            // 텍스트 정리
            const cleaned = text.trim().toLowerCase();
            
            // 너무 긴 텍스트는 제외 (보통 동물 이름은 5글자 이하)
            if (cleaned.length > 5) return false;
            
            // 조사나 문장 부호가 포함된 경우 제외
            if (/[.,!?~]/.test(cleaned)) return false;
            
            // 동물 이름 패턴에 포함되는지 확인
            return animalPatterns.some(animal => 
                cleaned === animal || 
                cleaned.includes(animal) || 
                animal.includes(cleaned)
            );
        }
        
        // 공통 범주 기반 전환 분석 알고리즘 (CFTSCORING과 동일)
        function analyzeTransitionsAndClusters(responses) {
            console.log('=== 전환 분석 시작 ===');
            console.log('입력된 동물들:', responses.map(r => r.normalizedResponse));
            
            if (responses.length === 0) return { transitions: [], clusters: [], switchingScore: 0, inefficientSwitchingScore: 0 };
            
            // 중복 제거하여 unique한 동물만 남기되, 순서는 첫 출현 순서 유지
            const seenAnimals = new Set();
            const uniqueResponses = [];
            
            for (const response of responses) {
                if (!seenAnimals.has(response.normalizedResponse)) {
                    seenAnimals.add(response.normalizedResponse);
                    uniqueResponses.push(response);
                }
            }
            
            console.log('중복 제거 후 동물들:', uniqueResponses.map(r => r.normalizedResponse));
            
            // 각 동물의 범주 정보를 미리 준비
            const animalData = [];
            for (const response of uniqueResponses) {
                const originalAnimal = response.normalizedResponse;
                const normalizedAnimal = normalizeAnimalName(originalAnimal);
                const animal = normalizedAnimal || originalAnimal;
                const categories = [];
                const categoryData = ANIMAL_CATEGORIES[animal] || {};
                
                for (const [cat, value] of Object.entries(categoryData)) {
                    if (value === true) {
                        categories.push(cat);
                    }
                }
                
                animalData.push({
                    name: animal,
                    categories: categories,
                    originalName: originalAnimal
                });
            }
            
            // 클러스터링 및 전환 분석
            const clusters = [];
            const transitions = [];
            let switchingScore = 0;
            let inefficientSwitchingScore = 0;
            
            let currentClusterStart = 0;
            let currentClusterCategories = [...animalData[0].categories]; // 첫 동물의 모든 범주로 시작
            
            console.log(`\n첫 동물: ${animalData[0].name}, 범주: ${currentClusterCategories.map(c => CATEGORIES[c] || c)}`);
            
            for (let i = 1; i < animalData.length; i++) {
                const currentAnimal = animalData[i];
                console.log(`\n${i+1}번째 동물: ${currentAnimal.name}`);
                console.log(`  범주: ${currentAnimal.categories.map(c => CATEGORIES[c] || c)}`);
                
                // 현재 클러스터의 공통 범주와 겹치는 범주가 있는지 확인
                const overlappingCategories = currentAnimal.categories.filter(cat => 
                    currentClusterCategories.includes(cat)
                );
                
                console.log(`  현재 클러스터 공통범주: ${currentClusterCategories.map(c => CATEGORIES[c] || c)}`);
                console.log(`  겹치는 범주: ${overlappingCategories.map(c => CATEGORIES[c] || c)}`);
                
                if (overlappingCategories.length > 0) {
                    // 겹치는 범주가 있으면 같은 클러스터에 속함
                    // 공통 범주를 겹치는 범주로 업데이트
                    currentClusterCategories = overlappingCategories;
                    console.log(`  → 같은 클러스터 유지, 공통범주 업데이트: ${currentClusterCategories.map(c => CATEGORIES[c] || c)}`);
                } else {
                    // 겹치는 범주가 없으면 전환 발생
                    console.log(`  → 전환 발생!`);
                    
                    // 이전 클러스터 저장
                    const clusterSize = i - currentClusterStart;
                    const clusterAnimals = animalData.slice(currentClusterStart, i).map(a => a.name);
                    
                    // 클러스터의 최종 공통 범주 결정 (최대 크기를 만드는 범주)
                    const bestCategory = findBestCategoryForCluster(animalData.slice(currentClusterStart, i));
                    
                    clusters.push({
                        animals: clusterAnimals,
                        size: clusterSize,
                        commonCategories: bestCategory.categories,
                        startIndex: currentClusterStart,
                        endIndex: i - 1
                    });
                    
                    console.log(`  이전 클러스터: ${clusterAnimals.join(', ')} (크기: ${clusterSize}, 범주: ${bestCategory.categories.map(c => CATEGORIES[c] || c)})`);
                    
                    // 전환 정보 추가
                    transitions.push({
                        index: i,
                        from: animalData[i-1].name,
                        to: currentAnimal.name,
                        fromCategories: animalData[i-1].categories,
                        toCategories: currentAnimal.categories
                    });
                    switchingScore++;
                    
                    // 크기 1인 클러스터에서 전환이면 비효율 전환
                    if (clusterSize === 1) {
                        inefficientSwitchingScore++;
                        console.log(`  → 비효율 전환! (크기 1인 클러스터에서 전환)`);
                    }
                    
                    // 새로운 클러스터 시작
                    currentClusterStart = i;
                    currentClusterCategories = [...currentAnimal.categories];
                }
            }
            
            // 마지막 클러스터 저장
            if (animalData.length > 0) {
                const lastClusterSize = animalData.length - currentClusterStart;
                const lastClusterAnimals = animalData.slice(currentClusterStart).map(a => a.name);
                const bestLastCategory = findBestCategoryForCluster(animalData.slice(currentClusterStart));
                
                clusters.push({
                    animals: lastClusterAnimals,
                    size: lastClusterSize,
                    commonCategories: bestLastCategory.categories,
                    startIndex: currentClusterStart,
                    endIndex: animalData.length - 1
                });
                
                console.log(`\n마지막 클러스터: ${lastClusterAnimals.join(', ')} (크기: ${lastClusterSize}, 범주: ${bestLastCategory.categories.map(c => CATEGORIES[c] || c)})`);
            }
            
            console.log('\n=== 전환 분석 결과 ===');
            console.log(`총 전환 횟수: ${switchingScore}`);
            console.log(`비효율전환 횟수: ${inefficientSwitchingScore}`);
            console.log(`클러스터 수: ${clusters.length}`);
            console.log('클러스터 구성:');
            clusters.forEach((cluster, idx) => {
                const categoryNames = cluster.commonCategories.map(cat => CATEGORIES[cat] || cat).join(', ');
                console.log(`  클러스터 ${idx + 1}: ${cluster.animals.join(', ')} (크기: ${cluster.size}, 공통범주: ${categoryNames})`);
            });
            
            return { transitions, clusters, switchingScore, inefficientSwitchingScore };
        }
        
        // 클러스터에 대해 최적의 공통 범주를 찾는 함수
        function findBestCategoryForCluster(animals) {
            if (animals.length === 0) return { categories: [], count: 0 };
            if (animals.length === 1) return { categories: animals[0].categories, count: 1 };
            
            // 모든 가능한 범주 조합을 찾아서 가장 많은 동물을 포함하는 범주 선택
            const allCategories = new Set();
            animals.forEach(animal => {
                animal.categories.forEach(cat => allCategories.add(cat));
            });
            
            let bestCategories = [];
            let bestCount = 0;
            
            // 각 범주별로 몇 개의 동물이 속하는지 확인
            for (const category of allCategories) {
                const count = animals.filter(animal => 
                    animal.categories.includes(category)
                ).length;
                
                if (count > bestCount) {
                    bestCount = count;
                    bestCategories = [category];
                }
            }
            
            // 여러 범주의 교집합도 확인 (2개 범주의 교집합만)
            const categoriesArray = Array.from(allCategories);
            for (let i = 0; i < categoriesArray.length; i++) {
                for (let j = i + 1; j < categoriesArray.length; j++) {
                    const cat1 = categoriesArray[i];
                    const cat2 = categoriesArray[j];
                    
                    const count = animals.filter(animal => 
                        animal.categories.includes(cat1) && animal.categories.includes(cat2)
                    ).length;
                    
                    if (count > bestCount) {
                        bestCount = count;
                        bestCategories = [cat1, cat2];
                    }
                }
            }
            
            return { categories: bestCategories, count: bestCount };
        }
        
        function calculateIntervalStats() {
            const intervals = {
                '0-15초': [],
                '15-30초': [],
                '30-45초': [],
                '45-60초': []
            };
            
            animals.forEach(animal => {
                const seconds = animal.timestamp / 1000;
                if (seconds < 15) {
                    intervals['0-15초'].push(animal);
                } else if (seconds < 30) {
                    intervals['15-30초'].push(animal);
                } else if (seconds < 45) {
                    intervals['30-45초'].push(animal);
                } else {
                    intervals['45-60초'].push(animal);
                }
            });
            
            return intervals;
        }
        
        // CSV 데이터 생성
        function generateCSVData() {
            // 15초 간격으로 동물 분류
            const intervals = {
                '0-15초': [],
                '15-30초': [],
                '30-45초': [],
                '45-60초': []
            };
            
            animals.forEach(animal => {
                const seconds = animal.elapsedTime / 1000;
                if (seconds <= 15) {
                    intervals['0-15초'].push(animal.name);
                } else if (seconds <= 30) {
                    intervals['15-30초'].push(animal.name);
                } else if (seconds <= 45) {
                    intervals['30-45초'].push(animal.name);
                } else {
                    intervals['45-60초'].push(animal.name);
                }
            });
            
            // CSV 헤더와 데이터 생성 - BOM 추가로 한글 인코딩 문제 해결
            let csv = '\ufeff';  // UTF-8 BOM 추가
            csv += 'ID,성별,연령,학력,0-15초,15-30초,30-45초,45-60초\n';
            
            // 사용자 정보 사용
            const id = userInfo.participantId || 'TEST001';
            const gender = userInfo.gender || '미입력';
            const age = userInfo.age || '미입력';
            const education = userInfo.education || '미입력';
            
            // 각 구간의 동물들을 쉼표로 연결
            const interval0_15 = intervals['0-15초'].join(',');
            const interval15_30 = intervals['15-30초'].join(',');
            const interval30_45 = intervals['30-45초'].join(',');
            const interval45_60 = intervals['45-60초'].join(',');
            
            csv += `${id},${gender},${age},${education},"${interval0_15}","${interval15_30}","${interval30_45}","${interval45_60}"`;
            
            console.log('생성된 CSV 데이터:');
            console.log(csv);
            console.log('구간별 동물 수:', {
                '0-15초': intervals['0-15초'].length,
                '15-30초': intervals['15-30초'].length,
                '30-45초': intervals['30-45초'].length,
                '45-60초': intervals['45-60초'].length
            });
            
            return csv;
        }
        
        // CFTSCORING 통합 분석 함수 (V15에서는 CSV 다운로드 없이 백그라운드 처리)
        function analyzeWithCFTSCORING() {
            console.log('CFTSCORING 통합 분석 시작...');
            
            // 분석 중 오버레이는 이미 표시됨 (V21)
            
            // CSV 데이터 생성 전에 기본 정보 설정
            console.log('현재 animals 배열:', animals);
            console.log('animals 길이:', animals.length);
            
            if (!animals || animals.length === 0) {
                console.log('분석할 데이터가 없습니다. 내부 분석을 사용합니다.');
                setTimeout(() => {
                    document.getElementById('analyzing-overlay').style.display = 'none';
                    performInternalAnalysis();
                }, 500);
                return;
            }
            
            // CSV 데이터 생성
            const csvData = generateCSVData();
            console.log('생성된 CSV 데이터:', csvData);
            
            // CSV 다운로드 없이 바로 CFTSCORING 분석 수행
            setTimeout(() => {
                try {
                    performCFTSCORINGAnalysis(csvData);
                } catch (error) {
                    console.error('CFTSCORING 분석 오류:', error);
                    document.getElementById('analyzing-overlay').style.display = 'none';
                    performInternalAnalysis();
                }
            }, 100);
        }
        
        // CFTSCORING iframe을 통한 분석 (사용하지 않음 - 404 오류 방지)
        function performCFTSCORINGAnalysisWithIframe(csvData) {
            console.log('iframe 방식 대신 직접 분석을 사용합니다.');
            performCFTSCORINGAnalysis(csvData);
        }
        
        // CFTSCORING 결과로부터 HTML 생성
        function generateCFTSCORINGResultFromData(result) {
            const testDate = new Date().toLocaleDateString('ko-KR');
            
            let html = `
                <div class="result-container" style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 800px; margin: 0 auto;">
                    <h2 style="text-align: center; color: #333; margin-bottom: 30px;">동물 유창성 검사 결과</h2>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: #495057; margin-bottom: 15px;">기본 정보</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                            <p><strong>ID:</strong> ${result.id}</p>
                            <p><strong>검사일:</strong> ${testDate}</p>
                            <p><strong>성별:</strong> ${result.gender}</p>
                            <p><strong>연령:</strong> ${result.age}세</p>
                            <p><strong>학력:</strong> ${result.education}년</p>
                        </div>
                    </div>
                    
                    <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: #1976d2; margin-bottom: 15px;">주요 점수</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                            <div>
                                <p style="font-size: 18px; margin: 5px 0;"><strong>총점:</strong> <span style="color: #1976d2; font-size: 24px;">${result.totalScore}</span>점</p>
                                <p><strong>전반부 (0-30초):</strong> ${result.firstHalfScore}점</p>
                                <p><strong>후반부 (30-60초):</strong> ${result.secondHalfScore}점</p>
                            </div>
                            <div>
                                <p><strong>보속:</strong> ${result.perseverationScore}개</p>
                                <p><strong>침투:</strong> ${result.intrusionScore}개</p>
                                <p><strong>전환:</strong> ${result.switchingScore}회</p>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: #7b1fa2; margin-bottom: 15px;">클러스터 분석</h3>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                            <p><strong>범주 수:</strong> ${result.clusterCount || 0}개</p>
                            <p><strong>평균 크기:</strong> ${result.avgClusterSize || 0}</p>
                            <p><strong>최대 크기:</strong> ${result.maxClusterSize || 0}</p>
                        </div>
                    </div>
                    
                    <div style="background: #fff3e0; padding: 20px; border-radius: 8px;">
                        <h3 style="color: #f57c00; margin-bottom: 15px;">구간별 반응</h3>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                            <p><strong>0-15초:</strong> ${result.interval1Count || 0}개</p>
                            <p><strong>15-30초:</strong> ${result.interval2Count || 0}개</p>
                            <p><strong>30-45초:</strong> ${result.interval3Count || 0}개</p>
                            <p><strong>45-60초:</strong> ${result.interval4Count || 0}개</p>
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        // CFTSCORING 분석 수행 함수 (폴백)
        function performCFTSCORINGAnalysis(csvData) {
            console.log('CFTSCORING 분석 수행 시작...');
            console.log('받은 CSV 데이터:', csvData);
            
            try {
                // CSV 데이터 파싱
                const rows = parseCSV(csvData);
                console.log('파싱된 행 수:', rows.length);
                
                if (rows.length < 2) {
                    console.error('데이터가 없습니다.');
                    document.getElementById('analyzing-overlay').style.display = 'none';
                    performInternalAnalysis();
                    return;
                }
                
                // 첫 번째 데이터 행 처리 (헤더 제외)
                const dataRow = rows[1];
                const id = dataRow[0];
                const gender = dataRow[1];
                const age = parseInt(dataRow[2]) || 0;
                const education = parseInt(dataRow[3]) || 0;
                
                // 각 시간대별 반응 파싱
                const responses = {
                    '0-15': parseAnimals(dataRow[4]),
                    '15-30': parseAnimals(dataRow[5]),
                    '30-45': parseAnimals(dataRow[6]),
                    '45-60': parseAnimals(dataRow[7])
                };
                
                // CFTSCORING 점수 계산
                const scores = calculateCFTScores({
                    id: id,
                    gender: gender,
                    age: age,
                    education: education,
                    responses: responses
                });
                
                // 결과 HTML 생성
                const resultHTML = generateCFTSCORINGResultHTML(scores);
                console.log('생성된 결과 HTML:', resultHTML ? '있음' : '없음');
                console.log('결과 HTML 길이:', resultHTML ? resultHTML.length : 0);
                
                // 분석 중 오버레이 숨기기
                document.getElementById('analyzing-overlay').style.display = 'none';
                
                // 결과 표시
                console.log('displayCFTSCORINGResults 호출 직전');
                displayCFTSCORINGResults(resultHTML);
                
            } catch (error) {
                console.error('CFTSCORING 분석 중 오류:', error);
                document.getElementById('analyzing-overlay').style.display = 'none';
                alert('CFTSCORING 분석 중 오류가 발생했습니다. 내부 분석을 사용합니다.');
                performInternalAnalysis();
            }
        }
        
        // CSV 파싱 함수
        function parseCSV(csv) {
            const lines = csv.split('\n');
            const rows = [];
            
            for (let line of lines) {
                if (line.trim()) {
                    const row = [];
                    let cell = '';
                    let insideQuotes = false;
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        
                        if (char === '"') {
                            insideQuotes = !insideQuotes;
                        } else if (char === ',' && !insideQuotes) {
                            row.push(cell.trim());
                            cell = '';
                        } else {
                            cell += char;
                        }
                    }
                    
                    // 마지막 셀 추가
                    row.push(cell.trim());
                    rows.push(row);
                }
            }
            
            return rows;
        }
        
        // 동물 이름 파싱
        function parseAnimals(text) {
            if (!text) return [];
            return text.split(',').map(a => a.trim()).filter(a => a.length > 0);
        }
        
        // CFTSCORING 점수 계산 - CFTSCORING.html의 정확한 알고리즘 사용
        function calculateCFTScores(data) {
            // 모든 반응을 순서대로 정리
            const allResponses = [];
            let order = 1;
            
            ['0-15', '15-30', '30-45', '45-60'].forEach(range => {
                const timeRange = range;
                (data.responses[range] || []).forEach(response => {
                    const trimmed = response.trim();
                    if (!trimmed) return;
                    
                    // 정규화된 동물 이름 찾기
                    const normalizedResponse = normalizeAnimalName(trimmed);
                    
                    allResponses.push({
                        response: trimmed,
                        originalResponse: trimmed,
                        normalizedResponse: normalizedResponse,
                        timeRange: timeRange,
                        order: order++
                    });
                });
            });
            
            // 유효한 반응 (정규화된 동물 이름이 있는 것)
            const validResponses = allResponses.filter(r => r.normalizedResponse !== null);
            const uniqueResponses = [...new Set(validResponses.map(r => r.normalizedResponse))];
            const totalScore = uniqueResponses.length;
            
            // 전반/후반 점수
            const firstHalfResponses = allResponses.filter(r => 
                (r.timeRange === '0-15' || r.timeRange === '15-30') && r.normalizedResponse !== null
            );
            const firstHalfScore = new Set(firstHalfResponses.map(r => r.normalizedResponse)).size;
            
            const secondHalfResponses = allResponses.filter(r => 
                (r.timeRange === '30-45' || r.timeRange === '45-60') && r.normalizedResponse !== null
            );
            const secondHalfScore = new Set(secondHalfResponses.map(r => r.normalizedResponse)).size;
            
            // 보속 오류 계산
            const responseCount = {};
            validResponses.forEach(r => {
                responseCount[r.normalizedResponse] = (responseCount[r.normalizedResponse] || 0) + 1;
            });
            const perseverationScore = Object.values(responseCount)
                .filter(count => count > 1)
                .reduce((sum, count) => sum + (count - 1), 0);
            
            // 침투 오류 계산
            const intrusionScore = allResponses.filter(r => r.normalizedResponse === null).length;
            
            // CFTSCORING의 정확한 전환 및 클러스터 분석
            const { transitions, clusters, switchingScore, inefficientSwitchingScore } = 
                analyzeTransitionsAndClusters(validResponses);
            
            // 범주 점수 계산 (크기 2 이상의 클러스터만 범주로 인정)
            const validClusters = clusters.filter(cluster => cluster.size >= 2);
            const usedCategories = new Set();
            validClusters.forEach(cluster => {
                if (cluster.commonCategories.length > 0) {
                    usedCategories.add(cluster.commonCategories[0]);
                }
            });
            const categoryScore = usedCategories.size;
            
            // 클러스터 통계
            const validClusterSizes = validClusters.map(c => c.size);
            const avgClusterSize = validClusterSizes.length > 0 
                ? (validClusterSizes.reduce((sum, size) => sum + size, 0) / validClusterSizes.length).toFixed(1)
                : '0.0';
            const maxClusterSize = Math.max(...validClusterSizes, 0);
            
            // 구간별 동물 정리
            const intervalAnimals = {
                '0-15': [],
                '15-30': [],
                '30-45': [],
                '45-60': []
            };
            
            allResponses.forEach(r => {
                if (r.normalizedResponse) {
                    intervalAnimals[r.timeRange].push(r.normalizedResponse);
                }
            });
            
            return {
                id: data.id,
                gender: data.gender,
                age: data.age,
                education: data.education,
                totalScore: totalScore,
                firstHalfScore: firstHalfScore,
                secondHalfScore: secondHalfScore,
                perseverationScore: perseverationScore,
                intrusionScore: intrusionScore,
                switchingScore: switchingScore,
                inefficientSwitchingScore: inefficientSwitchingScore,
                clusterCount: clusters.length,
                categoryScore: categoryScore,
                avgClusterSize: avgClusterSize,
                maxClusterSize: maxClusterSize,
                clusterSizes: validClusterSizes,
                intervalAnimals: intervalAnimals,
                allAnimals: validResponses.map(r => r.normalizedResponse),
                clusters: clusters,
                transitions: transitions
            };
        }
        
        // 간단한 동물 이름 유효성 검사
        function isValidAnimalName(name) {
            // 기본적인 동물 이름 패턴 검사
            const commonAnimals = ['개', '고양이', '소', '말', '돼지', '닭', '호랑이', '사자', '토끼', '쿠'];
            return commonAnimals.some(animal => name.includes(animal)) || name.length >= 2;
        }
        
                        currentCluster = [animal];
                    }
                }
            });
            
            if (currentCluster.length > 1) {
                clusters.push(currentCluster);
            }
            
            const clusterCount = clusters.length;
            const avgClusterSize = clusterCount > 0 ? clusters.reduce((sum, c) => sum + c.length, 0) / clusterCount : 0;
            const maxClusterSize = clusterCount > 0 ? Math.max(...clusters.map(c => c.length)) : 0;
            const switchingScore = Math.max(0, animals.length - clusters.reduce((sum, c) => sum + c.length, 0));
            
            return {
                clusterCount: clusterCount,
                avgClusterSize: avgClusterSize.toFixed(1),
                maxClusterSize: maxClusterSize,
                switchingScore: switchingScore
            };
        }
        
        // 간단한 카테고리 판단
        
        // CFTSCORING 결과 HTML 생성 - CFTSCORING.html과 완전히 동일한 디자인
        function generateCFTSCORINGResultHTML(scores) {
            const testDate = new Date().toLocaleDateString('ko-KR');
            
            // Z-score와 퍼센타일 계산
            const zScore = ((scores.totalScore - 15) / 5).toFixed(2);
            const percentile = Math.min(99, Math.max(1, Math.round(50 + (zScore * 16))));
            
            // 패턴 분석 결과 생성
            const interpretationData = {
                uniqueCount: scores.totalScore,
                intervalCounts: {
                    '0-15초': scores.intervalAnimals['0-15'].length,
                    '15-30초': scores.intervalAnimals['15-30'].length,
                    '30-45초': scores.intervalAnimals['30-45'].length,
                    '45-60초': scores.intervalAnimals['45-60'].length
                },
                duplicates: scores.perseverationScore,
                intrusions: scores.intrusionScore,
                numberOfClusters: scores.clusterCount,
                meanClusterSize: scores.avgClusterSize,
                clusterSizes: scores.clusterSizes || []
            };
            
            console.log('해석 데이터:', interpretationData);
            const patternAnalysis = analyzePatternAndGenerateInterpretation(interpretationData);
            console.log('생성된 해석:', patternAnalysis);
            
            // CFTSCORING과 동일한 CSS 스타일 사용
            let html = `
                <style>
                    .score-table {
                        width: 100%;
                        max-width: 1200px;
                        margin: 0 auto;
                        table-layout: fixed;
                        border-collapse: collapse;
                        background: white;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                        border-radius: 10px;
                        overflow: hidden;
                        margin-bottom: 20px;
                    }
                    
                    .score-table th,
                    .score-table td {
                        padding: 8px 10px;
                        text-align: center;
                        border: 1px solid #e0e0e0;
                    }
                    
                    .score-table th {
                        background-color: #f5f5f5;
                        font-weight: 600;
                        color: #333;
                        font-size: 13px;
                        white-space: nowrap;
                        padding: 10px 8px;
                    }
                    
                    .score-table tr.header-row {
                        background-color: #f5f5f5;
                    }
                    
                    .score-table td {
                        font-size: 16px;
                        font-weight: bold;
                        color: #1565c0;
                        white-space: nowrap;
                        background-color: white;
                    }
                    
                    .score-table tbody td:first-child:not(.data-cell) {
                        font-weight: bold;
                        background-color: #f5f5f5;
                    }
                </style>
                
                <div style="max-width: 1200px; margin: 0 auto; padding: 20px;">
                    <h2 style="text-align: center; color: #90a4ae; font-size: 24px; font-weight: 500; margin: 30px 0 20px 0;">동물 유창성 검사 결과</h2>
                    
                    <!-- 기본 정보 -->
                    <div style="background: #f8f9fa; padding: 25px; border-radius: 15px; margin-bottom: 20px; border: 1px solid #e0e0e0; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; text-align: center;">
                            <p style="margin: 0;"><strong>ID:</strong> ${scores.id}</p>
                            <p style="margin: 0;"><strong>검사일:</strong> ${testDate}</p>
                            <p style="margin: 0;"><strong>성별:</strong> ${scores.gender}</p>
                            <p style="margin: 0;"><strong>연령:</strong> ${scores.age}세</p>
                            <p style="margin: 0;"><strong>학력:</strong> ${scores.education}년</p>
                        </div>
                    </div>
                    
                    <!-- CFTSCORING 형식의 통합 결과 테이블 -->
                    <table class="score-table">
                        <colgroup>
                            <col style="width: 15%;">
                            <col style="width: 12.14%;">
                            <col style="width: 12.14%;">
                            <col style="width: 12.14%;">
                            <col style="width: 12.14%;">
                            <col style="width: 12.14%;">
                            <col style="width: 12.14%;">
                            <col style="width: 12.14%;">
                        </colgroup>
                        <tbody>
                            <!-- 60초 반응 첫번째 행 -->
                            <tr class="header-row">
                                <th rowspan="4" style="vertical-align: middle; font-weight: bold; background-color: #e8f4f8;">60초 반응</th>
                                <th>총점</th>
                                <th>Z점수</th>
                                <th>퍼센타일</th>
                                <th>전반점수</th>
                                <th>후반점수</th>
                                <th>보속오류</th>
                                <th>침투오류</th>
                            </tr>
                            <tr class="data-row">
                                <td class="data-cell" style="font-size: 18px; color: #1565c0;">${scores.totalScore}</td>
                                <td class="data-cell">${zScore}</td>
                                <td class="data-cell">${percentile}%</td>
                                <td class="data-cell">${scores.firstHalfScore}</td>
                                <td class="data-cell">${scores.secondHalfScore}</td>
                                <td class="data-cell">${scores.perseverationScore}</td>
                                <td class="data-cell">${scores.intrusionScore}</td>
                            </tr>
                            
                            <!-- 전환 분석 행 -->
                            <tr class="header-row">
                                <th>전환</th>
                                <th>비효율전환</th>
                                <th>범주수</th>
                                <th>평균크기</th>
                                <th>최대크기</th>
                                <th colspan="2">클러스터 크기 분포</th>
                            </tr>
                            <tr class="data-row">
                                <td class="data-cell">${scores.switchingScore}</td>
                                <td class="data-cell">${scores.inefficientSwitchingScore || 0}</td>
                                <td class="data-cell">${scores.clusterCount}</td>
                                <td class="data-cell">${scores.avgClusterSize}</td>
                                <td class="data-cell">${scores.maxClusterSize}</td>
                                <td class="data-cell" colspan="2">${scores.clusterSizes ? scores.clusterSizes.join(', ') : ''}</td>
                            </tr>
                            
                            <!-- 시간대별 정보 -->
                            <tr class="header-row">
                                <th rowspan="2" style="vertical-align: middle; font-weight: bold; background-color: #e8f4f8;">시간대별<br>분석</th>
                                <th>구간</th>
                                <th>0-15초</th>
                                <th>15-30초</th>
                                <th>30-45초</th>
                                <th>45-60초</th>
                                <th colspan="2">합계</th>
                            </tr>
                            <tr class="data-row">
                                <td style="font-weight: bold; background-color: #f5f5f5;">개수</td>
                                <td class="data-cell">${scores.intervalAnimals['0-15'].length}</td>
                                <td class="data-cell">${scores.intervalAnimals['15-30'].length}</td>
                                <td class="data-cell">${scores.intervalAnimals['30-45'].length}</td>
                                <td class="data-cell">${scores.intervalAnimals['45-60'].length}</td>
                                <td class="data-cell" colspan="2" style="font-weight: bold;">${scores.totalScore}</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <!-- 임상적 해석 (CFTSCORING의 patternAnalysis 동일 스타일) -->
                    <div id="patternAnalysis" style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px; border-left: 4px solid #1976d2;">
                        <div style="line-height: 1.8; color: #333;">
                            ${patternAnalysis || '해석 생성 중입니다...'}
                        </div>
                    </div>
                    
                    <!-- 버튼들 -->
                    <div style="text-align: center; margin-top: 30px;">
                        <button onclick="showAnalysisDetails()" style="background-color: #17a2b8; color: white; border: none; padding: 12px 30px; font-size: 16px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.2); margin-right: 10px;">
                            분석 과정 보기
                        </button>
                        <button onclick="window.location.reload()" style="background-color: #1976d2; color: white; border: none; padding: 12px 30px; font-size: 16px; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                            다시 검사하기
                        </button>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        // CFTSCORING 결과 표시
        function displayCFTSCORINGResults(resultHTML) {
            console.log('displayCFTSCORINGResults 호출됨');
            
            // resultsSection 다시 확인
            if (!resultsSection) {
                resultsSection = document.getElementById('resultsSection');
            }
            
            if (!resultsSection) {
                console.error('resultsSection을 찾을 수 없습니다!');
                // 대체 방법: body에 직접 추가
                const div = document.createElement('div');
                div.id = 'cftscoring-results';
                div.innerHTML = resultHTML;
                div.style.cssText = 'padding: 20px; max-width: 1200px; margin: 20px auto;';
                document.body.appendChild(div);
                div.scrollIntoView({ behavior: 'smooth' });
                speak('검사가 완료되었습니다. 결과를 확인해주세요.');
                return;
            }
            
            // 결과 섹션 표시
            console.log('결과 HTML 길이:', resultHTML.length);
            resultsSection.innerHTML = resultHTML;
            resultsSection.style.display = 'block';
            resultsSection.style.visibility = 'visible';
            resultsSection.style.opacity = '1';
            
            // 타이머 및 컨트롤 버튼 숨기기
            const timerElement = document.getElementById('timer');
            const stopButton = document.getElementById('stopBtn');
            const testPage = document.getElementById('testPage');
            
            if (timerElement) timerElement.style.display = 'none';
            if (stopButton) stopButton.style.display = 'none';
            // Don't hide testPage since resultsSection is inside it
            // if (testPage) testPage.style.display = 'none';  // 검사 페이지 숨기기
            
            // Instead, hide specific elements inside testPage
            const readyBox = document.getElementById('readyBox');
            const testScreen = document.getElementById('testScreen');
            const voiceGuideBox = document.getElementById('voiceGuideBox');
            const recordingIndicator = document.getElementById('recordingIndicator');
            const controlButtons = document.querySelector('.control-buttons');
            
            if (readyBox) readyBox.style.display = 'none';
            if (testScreen) testScreen.style.display = 'none';
            if (voiceGuideBox) voiceGuideBox.style.display = 'none';
            if (recordingIndicator) recordingIndicator.style.display = 'none';
            if (controlButtons) controlButtons.style.display = 'none';
            
            // 결과 영역으로 스크롤
            setTimeout(() => {
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                console.log('스크롤 완료');
            }, 100);
            
            // 결과 음성 안내
            speak('검사가 완료되었습니다. 결과를 확인해주세요.');
        }
        
        // 내부 분석 (폴백)
        function performInternalAnalysis() {
            console.log('내부 분석 시작...');
            
            // 분석 중 오버레이 숨기기
            document.getElementById('analyzing-overlay').style.display = 'none';
            
            // 상세한 내부 분석 수행
            analyzeInternalClusters();
        }
        
        // 클러스터 분석 함수 (내부 분석용)
        function analyzeInternalClusters() {
            console.log('analyzeInternalClusters 시작');
            
            // resultsSection 변수 확인 및 가져오기
            if (!resultsSection) {
                resultsSection = document.getElementById('resultsSection');
            }
            
            if (!resultsSection) {
                console.error('결과 섹션을 찾을 수 없습니다.');
                return;
            }
            
            const testDate = new Date();
            const totalCount = animals.length;
            const intervalStats = calculateIntervalStats();
            const intervalCounts = {
                '0-15초': intervalStats['0-15초'].length,
                '15-30초': intervalStats['15-30초'].length,
                '30-45초': intervalStats['30-45초'].length,
                '45-60초': intervalStats['45-60초'].length
            };
            
            // 전반부/후반부 분석
            const firstHalfCount = intervalCounts['0-15초'] + intervalCounts['15-30초'];
            const secondHalfCount = intervalCounts['30-45초'] + intervalCounts['45-60초'];
            
            // 중복 및 침투 계산
            const animalFrequency = {};
            let intrusionCount = 0;
            let validAnimalCount = 0;
            
            animals.forEach(animal => {
                if (animal.isAnimal) {
                    // 동물인 경우 기본형으로 중복 체크
                    const baseAnimal = animal.baseAnimal || animal.name;
                    animalFrequency[baseAnimal] = (animalFrequency[baseAnimal] || 0) + 1;
                    validAnimalCount++;
                } else {
                    // 동물이 아닌 경우 침투로 계산
                    intrusionCount++;
                }
            });
            const duplicates = Object.values(animalFrequency).filter(count => count > 1).reduce((sum, count) => sum + (count - 1), 0);
            
            // CFTSCORING 알고리즘으로 클러스터 분석
            const allResponses = [];
            animals.forEach((animal, index) => {
                const timestamp = animal.timestamp;
                const timeSeconds = Math.floor(timestamp / 1000);
                const timeRange = timeSeconds < 15 ? '0-15' : 
                                timeSeconds < 30 ? '15-30' : 
                                timeSeconds < 45 ? '30-45' : '45-60';
                
                const normalizedResponse = normalizeAnimalName(animal.name);
                if (normalizedResponse) {
                    allResponses.push({
                        response: animal.name,
                        normalizedResponse: normalizedResponse,
                        timeRange: timeRange,
                        order: index + 1
                    });
                }
            });
            
            const { transitions, clusters, switchingScore, inefficientSwitchingScore } = 
                analyzeTransitionsAndClusters(allResponses);
            
            // 가중치 점수 계산 (CFTSCORING 알고리즘)
            const weightedScore = intervalCounts['0-15초'] * 1.0 + 
                                intervalCounts['15-30초'] * 0.75 + 
                                intervalCounts['30-45초'] * 0.5 + 
                                intervalCounts['45-60초'] * 0.25;
            
            // 범주 점수 계산 (크기 2 이상의 클러스터만 범주로 인정)
            const validClusters = clusters.filter(cluster => cluster.size >= 2);
            const usedCategories = new Set();
            validClusters.forEach(cluster => {
                if (cluster.commonCategories.length > 0) {
                    usedCategories.add(cluster.commonCategories[0]);
                }
            });
            const categoryScore = usedCategories.size;
            
            // 클러스터 통계
            const validClusterSizes = validClusters.map(c => c.size);
            const avgClusterSize = validClusterSizes.length > 0 
                ? (validClusterSizes.reduce((sum, size) => sum + size, 0) / validClusterSizes.length).toFixed(1)
                : '0.0';
            const maxClusterSize = Math.max(...validClusterSizes, 0);
            
            // CFTSCORING 판독문 생성
            const scores = {
                uniqueCount: uniqueCount,
                intervalCounts: intervalCounts,
                duplicates: duplicates,
                intrusions: 0, // 명사만 인식하므로 침투 오류는 0
                numberOfClusters: clusters.length,
                meanClusterSize: parseFloat(avgClusterSize),
                clusterSizes: validClusterSizes,
                switchingScore: switchingScore,
                inefficientSwitchingScore: inefficientSwitchingScore,
                categoryScore: categoryScore
            };
            
            const interpretationResult = analyzePatternAndGenerateInterpretation(scores);
            
            // 수행 수준 판정
            let performanceLevel = '';
            let performanceColor = '';
            if (uniqueCount >= 15) {
                performanceLevel = '정상 범위';
                performanceColor = '#28a745';
            } else if (uniqueCount >= 10) {
                performanceLevel = '경계선 수준';
                performanceColor = '#ffc107';
            } else {
                performanceLevel = '저조한 수행';
                performanceColor = '#dc3545';
            }
            
            // CFTSCORING 스타일의 상세 보고서 생성
            resultsSection.innerHTML = `
                <div style="max-width: 1200px; margin: 0 auto; padding: 20px;">
                    <!-- 헤더 -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0; text-align: center;">
                        <h1 style="margin: 0; font-size: 32px;">동물 범주 언어유창성검사 결과 보고서</h1>
                        <p style="margin-top: 10px; opacity: 0.9;">검사일시: ${testDate.toLocaleString()}</p>
                    </div>
                    
                    <!-- 주요 결과 요약 -->
                    <div style="background: white; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <h2 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">주요 결과</h2>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                            <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                                <div style="font-size: 48px; font-weight: bold; color: #667eea;">${uniqueCount}</div>
                                <div style="color: #666; margin-top: 5px;">고유 동물 수</div>
                            </div>
                            <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                                <div style="font-size: 48px; font-weight: bold; color: #764ba2;">${totalCount}</div>
                                <div style="color: #666; margin-top: 5px;">총 응답 수</div>
                            </div>
                            <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                                <div style="font-size: 48px; font-weight: bold; color: #ff6b6b;">${duplicates}</div>
                                <div style="color: #666; margin-top: 5px;">중복 응답</div>
                            </div>
                            <div style="text-align: center; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                                <div style="font-size: 48px; font-weight: bold; color: #51cf66;">${weightedScore.toFixed(1)}</div>
                                <div style="color: #666; margin-top: 5px;">가중치 점수</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 수행 평가 -->
                    <div style="background: white; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <h2 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">수행 평가</h2>
                        <div style="text-align: center; padding: 30px; background: ${performanceColor}20; border-radius: 10px; border: 2px solid ${performanceColor};">
                            <div style="font-size: 28px; font-weight: bold; color: ${performanceColor};">
                                ${performanceLevel}
                            </div>
                            <div style="margin-top: 10px; color: #666;">
                                ${uniqueCount >= 15 ? '정상적인 언어유창성을 보였습니다.' : 
                                  uniqueCount >= 10 ? '추가적인 평가가 필요할 수 있습니다.' : 
                                  '전문가 상담을 권장합니다.'}
                            </div>
                        </div>
                    </div>
                    
                    <!-- 시간대별 분석 -->
                    <div style="background: white; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <h2 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">시간대별 수행 분석</h2>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px;">
                            <div style="text-align: center;">
                                <div style="background: #667eea; color: white; padding: 10px; border-radius: 5px 5px 0 0;">0-15초</div>
                                <div style="background: #f8f9fa; padding: 20px; font-size: 24px; font-weight: bold;">${intervalCounts['0-15초']}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #764ba2; color: white; padding: 10px; border-radius: 5px 5px 0 0;">15-30초</div>
                                <div style="background: #f8f9fa; padding: 20px; font-size: 24px; font-weight: bold;">${intervalCounts['15-30초']}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #9775fa; color: white; padding: 10px; border-radius: 5px 5px 0 0;">30-45초</div>
                                <div style="background: #f8f9fa; padding: 20px; font-size: 24px; font-weight: bold;">${intervalCounts['30-45초']}</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="background: #b197fc; color: white; padding: 10px; border-radius: 5px 5px 0 0;">45-60초</div>
                                <div style="background: #f8f9fa; padding: 20px; font-size: 24px; font-weight: bold;">${intervalCounts['45-60초']}</div>
                            </div>
                        </div>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 10px;">
                            <div style="display: flex; justify-content: space-around;">
                                <div>
                                    <strong>전반부 (0-30초):</strong> ${firstHalfCount}개
                                </div>
                                <div>
                                    <strong>후반부 (30-60초):</strong> ${secondHalfCount}개
                                </div>
                                <div>
                                    <strong>감소율:</strong> ${firstHalfCount > 0 ? ((1 - secondHalfCount/firstHalfCount) * 100).toFixed(1) : 0}%
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 응답 목록 -->
                    <div style="background: white; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <h2 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">응답 목록</h2>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; max-height: 300px; overflow-y: auto;">
                            ${animals.map((animal, index) => {
                                const time = ((animal.timestamp - startTime) / 1000).toFixed(1);
                                const isDuplicate = animalFrequency[animal.name] > 1;
                                return `<span style="display: inline-block; margin: 5px; padding: 5px 10px; background: ${isDuplicate ? '#ffe8e8' : '#e8f5e9'}; border-radius: 5px; ${isDuplicate ? 'color: #d32f2f;' : ''}">${index + 1}. ${animal.name} (${time}초)</span>`;
                            }).join('')}
                        </div>
                    </div>
                    
                    <!-- 클러스터 분석 -->
                    ${clusters.length > 0 ? `
                    <div style="background: white; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <h2 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">의미 범주 분석</h2>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 10px;">
                            <p><strong>확인된 의미 범주:</strong> ${clusters.length}개</p>
                            <div style="margin-top: 10px;">
                                ${clusters.map(cluster => `
                                    <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px;">
                                        <strong>${cluster.category}:</strong> ${cluster.items.join(', ')} (${cluster.items.length}개)
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <!-- CFTSCORING 판독 결과 -->
                    <div style="background: white; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <h2 style="color: #333; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">판독 결과</h2>
                        <div style="background: #f0f8ff; padding: 25px; border-radius: 10px; border-left: 5px solid #1565c0;">
                            <p style="line-height: 1.8; color: #333; font-size: 16px; margin: 0;">
                                ${interpretationResult.interpretation}
                            </p>
                        </div>
                    </div>
                    
                    <!-- 버튼 -->
                    <div style="text-align: center; margin-top: 30px;">
                        <button onclick="window.print()" style="background-color: #667eea; color: white; border: none; padding: 12px 30px; font-size: 16px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                            <i class="fas fa-print"></i> 인쇄하기
                        </button>
                        <button onclick="window.location.href = window.location.pathname" style="background-color: #764ba2; color: white; border: none; padding: 12px 30px; font-size: 16px; border-radius: 5px; cursor: pointer;">
                            <i class="fas fa-redo"></i> 다시 검사하기
                        </button>
                    </div>
                </div>
            `;
            
            resultsSection.style.display = 'block';
            resultsSection.scrollIntoView({ behavior: 'smooth' });
            
            // 음성 안내
            speak("분석이 완료되었습니다. 결과를 확인해 주세요.");
        }
        
        // CFTSCORING AnimalFluencyInterpreter 클래스 추가
        class AnimalFluencyInterpreter {
            constructor() {
                this.normData = {
                    '20-29': { mean: 21.7, sd: 5.1 },
                    '30-39': { mean: 21.2, sd: 5.2 },
                    '40-49': { mean: 19.8, sd: 4.8 },
                    '50-59': { mean: 18.5, sd: 4.6 },
                    '60-69': { mean: 16.3, sd: 4.4 },
                    '70-79': { mean: 14.2, sd: 3.9 },
                    '80+': { mean: 11.8, sd: 3.5 }
                };
                
                this.qualitative_criteria = {
                    최대범주크기: 4,
                    전환비율: 0.5,
                    비효율전환비율: 0.3
                };
            }
            
            getAgeGroup(age) {
                if (age < 30) return '20-29';
                if (age < 40) return '30-39';
                if (age < 50) return '40-49';
                if (age < 60) return '50-59';
                if (age < 70) return '60-69';
                if (age < 80) return '70-79';
                return '80+';
            }
            
            calculateZScore(score, ageGroup) {
                const norm = this.normData[ageGroup];
                return (score - norm.mean) / norm.sd;
            }
            
            calculatePercentile(zScore) {
                // 간단한 정규분포 근사
                const percentile = 50 + (zScore * 15);
                return Math.max(1, Math.min(99, Math.round(percentile)));
            }
            
            총점_해석(총점, z_score, percentile) {
                let 해석 = `총 ${총점}개의 동물을 말씀하셨습니다. `;
                let 수행수준 = '';
                
                if (z_score >= 0) {
                    해석 += `이는 연령 규준 상 평균 이상의 수행으로, 상위 ${100-percentile}% 수준입니다. `;
                    수행수준 = '정상';
                } else if (z_score > -1) {
                    해석 += `이는 연령 규준 상 평균 범위의 수행으로, 하위 ${percentile}% 수준입니다. `;
                    수행수준 = '정상';
                } else if (z_score > -1.5) {
                    해석 += `이는 연령 규준 상 평균 하 수준의 수행으로, 하위 ${percentile}% 수준입니다. `;
                    수행수준 = '경계선';
                } else {
                    해석 += `이는 연령 규준 상 현저히 낮은 수행으로, 하위 ${percentile}% 수준입니다. `;
                    수행수준 = '저하';
                }
                
                return [해석, 수행수준];
            }
            
            시간패턴_해석(전반30초, 후반30초) {
                const 감소율 = 전반30초 > 0 ? ((전반30초 - 후반30초) / 전반30초 * 100).toFixed(0) : 0;
                
                if (감소율 < 30) {
                    return `전반 30초와 후반 30초의 수행이 비교적 균등하여 지속적인 인출 능력을 보여줍니다.`;
                } else if (감소율 < 50) {
                    return `후반부로 갈수록 약간의 수행 저하가 관찰되나 정상 범위 내의 패턴입니다.`;
                } else {
                    return `후반부에 현저한 수행 저하(${감소율}% 감소)가 관찰되어 인출 효율성의 저하가 시사됩니다.`;
                }
            }
            
            오류_해석(보속오류, 침투오류) {
                let 해석 = [];
                
                if (보속오류 === 0 && 침투오류 === 0) {
                    해석.push("오류 반응 없이 정확한 수행을 보였습니다.");
                } else {
                    if (보속오류 > 0) {
                        if (보속오류 <= 2) {
                            해석.push(`${보속오류}회의 반복 오류가 있었으나 정상 범위입니다.`);
                        } else {
                            해석.push(`${보속오류}회의 반복 오류가 관찰되어 자기 점검 능력의 저하가 시사됩니다.`);
                        }
                    }
                    
                    if (침투오류 > 0) {
                        해석.push(`${침투오류}회의 침투 오류가 관찰되어 범주 유지 능력의 저하가 시사됩니다.`);
                    }
                }
                
                return 해석.join(" ");
            }
            
            범주크기_해석(평균범주크기, 최대범주크기, 범주수) {
                let 해석 = [];
                
                if (평균범주크기 >= 3) {
                    해석.push("의미적으로 연관된 항목들을 효과적으로 군집화하여 인출하였습니다.");
                } else if (평균범주크기 >= 2) {
                    해석.push("일부 의미적 군집화가 관찰되나 제한적입니다.");
                } else {
                    해석.push("의미적 군집화가 거의 관찰되지 않아 체계적 인출 전략이 부족합니다.");
                }
                
                if (최대범주크기 >= this.qualitative_criteria.최대범주크기) {
                    해석.push(`최대 ${최대범주크기}개의 항목을 포함하는 범주를 생성하여 특정 하위 범주에 대한 양호한 지식을 보여줍니다.`);
                }
                
                return 해석.join(" ");
            }
            
            전환패턴_해석(전환수, 비효율전환수, 범주수) {
                const 전환비율 = 범주수 > 0 ? 전환수 / 범주수 : 0;
                const 비효율전환비율 = 전환수 > 0 ? 비효율전환수 / 전환수 : 0;
                
                let 해석 = [];
                
                if (전환비율 >= 1.5) {
                    해석.push("범주 간 전환이 활발하여 인지적 유연성이 양호합니다.");
                } else if (전환비율 >= 0.8) {
                    해석.push("적절한 수준의 범주 간 전환을 보입니다.");
                } else {
                    해석.push("범주 간 전환이 제한적이어서 인지적 유연성의 저하가 시사됩니다.");
                }
                
                if (비효율전환비율 > 0.3) {
                    해석.push("비효율적 전환이 많아 체계적 인출 전략의 부족이 시사됩니다.");
                }
                
                return 해석.join(" ");
            }
            
            범주조직화_종합해석(범주수, 평균범주크기, 전환수, 비효율전환수) {
                if (범주수 >= 5 && 평균범주크기 >= 3) {
                    return "전반적으로 의미 기억의 조직화가 잘 유지되고 있으며, 효과적인 인출 전략을 사용하고 있습니다.";
                } else if (범주수 >= 3 && 평균범주크기 >= 2) {
                    return "의미 기억의 조직화가 부분적으로 유지되고 있으나, 인출 효율성은 다소 저하되어 있습니다.";
                } else {
                    return "의미 기억의 조직화와 체계적 인출 전략 사용에 어려움이 관찰됩니다.";
                }
            }
            
            임상프로파일_해석(전환수, 비효율전환수, 범주수, 평균범주크기, 최대범주크기) {
                // 알츠하이머 패턴: 낮은 총점, 작은 범주 크기, 적은 전환
                if (범주수 < 3 && 평균범주크기 < 2 && 전환수 < 5) {
                    return "수행 패턴이 의미 기억 저장소 자체의 손상을 시사하며, 추가적인 신경심리평가가 권장됩니다.";
                }
                
                // 전두엽 기능장애 패턴: 많은 비효율전환, 낮은 군집화
                if (비효율전환수 > 전환수 * 0.4 && 평균범주크기 < 2.5) {
                    return "수행 패턴이 실행기능의 저하를 시사하며, 전두엽 기능에 대한 추가 평가가 도움이 될 수 있습니다.";
                }
                
                return null;
            }
            
            특정패턴_판정(검사결과) {
                const patterns = [];
                
                // 초기 버스트 패턴
                if (검사결과['0-15초'] >= 검사결과.총점 * 0.5) {
                    patterns.push({
                        name: "초기 버스트",
                        message: "검사 초반에 집중적으로 반응이 나타나는 전형적인 패턴을 보입니다."
                    });
                }
                
                // 지속적 산출 패턴
                const 구간별_비율 = [
                    검사결과['0-15초'] / 검사결과.총점,
                    검사결과['15-30초'] / 검사결과.총점,
                    검사결과['30-45초'] / 검사결과.총점,
                    검사결과['45-60초'] / 검사결과.총점
                ];
                
                const 비율_표준편차 = this.계산_표준편차(구간별_비율);
                if (비율_표준편차 < 0.1) {
                    patterns.push({
                        name: "지속적 산출",
                        message: "시간대별로 균등한 산출을 보여 안정적인 인출 능력을 시사합니다."
                    });
                }
                
                return patterns.length > 0 ? patterns[0] : null;
            }
            
            계산_표준편차(배열) {
                const 평균 = 배열.reduce((a, b) => a + b, 0) / 배열.length;
                const 분산 = 배열.reduce((sum, x) => sum + Math.pow(x - 평균, 2), 0) / 배열.length;
                return Math.sqrt(분산);
            }
            
            통합_판독문_생성(검사결과) {
                const 판독문_구성요소 = [];
                
                // 1. 총점 기반 해석
                const [총점해석, 수행수준] = this.총점_해석(검사결과.총점, 검사결과.z_score, 검사결과.percentile);
                판독문_구성요소.push(총점해석);
                
                // 2. 시간 패턴 해석
                const 시간해석 = this.시간패턴_해석(검사결과.전반30초, 검사결과.후반30초);
                판독문_구성요소.push(시간해석);
                
                // 3. 오류 해석
                const 오류해석 = this.오류_해석(검사결과.보속오류, 검사결과.침투오류);
                판독문_구성요소.push(오류해석);
                
                // 4. 범주 크기 분석
                const 범주크기해석 = this.범주크기_해석(검사결과.평균범주크기, 검사결과.최대범주크기, 검사결과.범주수);
                판독문_구성요소.push(범주크기해석);
                
                // 5. 전환 패턴 분석
                const 전환해석 = this.전환패턴_해석(검사결과.전환수, 검사결과.비효율전환수, 검사결과.범주수);
                판독문_구성요소.push(전환해석);
                
                // 6. 범주 조직화 종합
                const 조직화해석 = this.범주조직화_종합해석(검사결과.범주수, 검사결과.평균범주크기, 검사결과.전환수, 검사결과.비효율전환수);
                판독문_구성요소.push(조직화해석);
                
                // 7. 임상 프로파일
                const 프로파일해석 = this.임상프로파일_해석(검사결과.전환수, 검사결과.비효율전환수, 검사결과.범주수, 검사결과.평균범주크기, 검사결과.최대범주크기);
                if (프로파일해석) {
                    판독문_구성요소.push(프로파일해석);
                }
                
                // 8. 특정 패턴 판정 추가
                const 특정패턴 = this.특정패턴_판정(검사결과);
                if (특정패턴) {
                    판독문_구성요소.push(특정패턴.message);
                }
                
                return 판독문_구성요소.join(" ");
            }
        }
        
        // 패턴 분석 함수 추가
        function analyzePatternAndGenerateInterpretation(scores) {
            const interpreter = new AnimalFluencyInterpreter();
            
            // 사용자 연령 기반 연령 그룹 결정
            const age = parseInt(userInfo.age) || 65; // 기본값 65세
            const ageGroup = interpreter.getAgeGroup(age);
            
            // Z-score와 percentile 계산
            const zScore = interpreter.calculateZScore(scores.uniqueCount, ageGroup);
            const percentile = interpreter.calculatePercentile(zScore);
            
            // 검사 결과 데이터 구성
            const totalScore = scores.uniqueCount;
            const switching = scores.numberOfClusters > 0 ? scores.numberOfClusters - 1 : 0;
            const meanClusterSize = scores.meanClusterSize || 1;
            const hardSwitching = Math.floor(switching * 0.2);
            
            const 검사결과 = {
                총점: totalScore,
                z_score: zScore,
                percentile: percentile,
                '0-15초': scores.intervalCounts['0-15초'] || 0,
                '15-30초': scores.intervalCounts['15-30초'] || 0,
                '30-45초': scores.intervalCounts['30-45초'] || 0,
                '45-60초': scores.intervalCounts['45-60초'] || 0,
                전반30초: (scores.intervalCounts['0-15초'] || 0) + (scores.intervalCounts['15-30초'] || 0),
                후반30초: (scores.intervalCounts['30-45초'] || 0) + (scores.intervalCounts['45-60초'] || 0),
                보속오류: scores.duplicates || 0,
                침투오류: scores.intrusions || 0,
                범주수: scores.numberOfClusters || 1,
                평균범주크기: meanClusterSize,
                최대범주크기: Math.max(...(scores.clusterSizes || [meanClusterSize])),
                전환수: switching,
                비효율전환수: hardSwitching
            };
            
            // 통합 판독문 생성
            const interpretation = interpreter.통합_판독문_생성(검사결과);
            console.log('생성된 해석:', interpretation);
            
            // 해석이 객체인 경우 interpretation 속성을 반환, 문자열인 경우 그대로 반환
            const finalInterpretation = typeof interpretation === 'object' && interpretation.interpretation 
                ? interpretation.interpretation 
                : interpretation;
            
            console.log('최종 해석:', finalInterpretation);
            
            return finalInterpretation || '검사 결과를 바탕으로 임상적 해석을 생성하는 중입니다.';
        }
        
        // 내부 분석 함수들은 모두 제거
        /*
            const counts = {
                '0-15초': intervalStats['0-15초'].length,
                '15-30초': intervalStats['15-30초'].length,
                '30-45초': intervalStats['30-45초'].length,
                '45-60초': intervalStats['45-60초'].length
            };
            
            // 전체 동물 리스트 (유효한 동물만)
            const allAnimals = [];
            const allValidAnimals = [];
            Object.values(intervalStats).forEach(interval => {
                interval.forEach(animal => {
                    allAnimals.push(animal.name);
                    if (animal.isAnimal) {
                        allValidAnimals.push(animal.name);
                    }
                });
            });
            
            // 전반부/후반부 계산
            const firstHalfAnimals = [...intervalStats['0-15초'], ...intervalStats['15-30초']];
            const secondHalfAnimals = [...intervalStats['30-45초'], ...intervalStats['45-60초']];
            const firstHalfScore = new Set(firstHalfAnimals).size;
            const secondHalfScore = new Set(secondHalfAnimals).size;
            
            // 보속 계산 (중복된 동물)
            const animalCounts = {};
            allAnimals.forEach(animal => {
                animalCounts[animal] = (animalCounts[animal] || 0) + 1;
            });
            const perseverationScore = Object.values(animalCounts).filter(count => count > 1).reduce((sum, count) => sum + (count - 1), 0);
            
            // 침투 계산은 이미 위에서 intrusionCount로 계산됨
            const intrusionScore = intrusionCount;
            
            // 범주 분석 (간단한 버전)
            const categoryAnalysis = analyzeClusters(allAnimals);
            
            // 가중치 점수 계산 (CFTSCORING 로직 참조)
            const weightedScore = 
                counts['0-15초'] * 1.0 + 
                counts['15-30초'] * 0.75 + 
                counts['30-45초'] * 0.5 + 
                counts['45-60초'] * 0.25;
            
            // 총점 (유효한 동물만 계산)
            const totalScore = validAnimalCount - duplicates;
            
            // 결과 해석
            let interpretation = '';
            if (totalScore >= 15) {
                interpretation = '정상 범위의 수행을 보이고 있습니다. 동물 이름 생성 능력이 연령대에 적합한 수준입니다. 범주 간 전환 능력과 지속적인 인출 능력이 양호합니다.';
            } else if (totalScore >= 10) {
                interpretation = '경계선 수준의 수행을 보이고 있습니다. 추가적인 인지기능 평가를 고려해볼 수 있습니다. 특히 전반부와 후반부의 수행 차이를 확인하는 것이 중요합니다.';
            } else {
                interpretation = '저조한 수행을 보이고 있습니다. 전문가의 상담을 받아보시기를 권합니다. 언어 유창성과 인지 기능에 대한 종합적인 평가가 필요할 수 있습니다.';
            }
            
            // 전문 분석 결과 HTML 생성 (CFTSCORING 스타일 적용)
            const resultHTML = `
                <style>
                    .results { background: white; padding: 30px; border-radius: 12px; margin-top: 20px; }
                    .score-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-bottom: 20px; }
                    .score-card { background: #f9f9f9; padding: 20px; border-radius: 8px; text-align: center; border: 1px solid #e0e0e0; transition: transform 0.2s; }
                    .score-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
                    .score-card h4 { font-size: 14px; color: #666; margin-bottom: 10px; font-weight: normal; }
                    .score { font-size: 32px; font-weight: bold; color: #2196F3; }
                    @media (max-width: 768px) { .score-grid { grid-template-columns: repeat(2, 1fr); } }
                </style>
                
                <div id="results" class="results">
                    <h2 style="color: #333; margin-bottom: 30px; text-align: center; font-size: 26px; border-bottom: 2px solid #e0e0e0; padding-bottom: 15px;">검사 결과</h2>
                    
                    <!-- 첫번째 줄: 총점, 전반점수, 후반점수, 보속, 침투 -->
                    <div class="score-grid">
                        <div class="score-card">
                            <h4>총점<br>(Total Score)</h4>
                            <div class="score">${totalScore}</div>
                        </div>
                        <div class="score-card">
                            <h4>전반점수<br>(First Half Score)</h4>
                            <div class="score">${firstHalfScore}</div>
                        </div>
                        <div class="score-card">
                            <h4>후반점수<br>(Second Half Score)</h4>
                            <div class="score">${secondHalfScore}</div>
                        </div>
                        <div class="score-card">
                            <h4>보속<br>(Perseveration)</h4>
                            <div class="score" style="color: ${perseverationScore > 2 ? '#FF5722' : '#2196F3'};">${perseverationScore}</div>
                        </div>
                        <div class="score-card">
                            <h4>침투<br>(Intrusion)</h4>
                            <div class="score">${intrusionScore}</div>
                        </div>
                    </div>
                    
                    <!-- 두번째 줄: 범주수, 평균범주크기, 최대범주크기, 전환, 비효율전환 -->
                    <div class="score-grid">
                        <div class="score-card">
                            <h4>범주수<br>(Number of Cluster)</h4>
                            <div class="score">${categoryAnalysis.numberOfClusters}</div>
                        </div>
                        <div class="score-card">
                            <h4>평균범주크기<br>(Mean Size of Cluster)</h4>
                            <div class="score">${categoryAnalysis.meanClusterSize}</div>
                        </div>
                        <div class="score-card">
                            <h4>최대범주크기<br>(Max Size of Cluster)</h4>
                            <div class="score">${categoryAnalysis.maxClusterSize}</div>
                        </div>
                        <div class="score-card">
                            <h4>전환<br>(Switching)</h4>
                            <div class="score">${categoryAnalysis.switching}</div>
                        </div>
                        <div class="score-card">
                            <h4>비효율전환<br>(Hard Switching)</h4>
                            <div class="score">${categoryAnalysis.hardSwitching}</div>
                        </div>
                    </div>
                    
                    <!-- 추가 분석 정보 -->
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
                        <h3 style="color: #495057; margin-bottom: 15px; font-size: 18px;">시간대별 상세 분석</h3>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                            <div style="text-align: center; padding: 15px; background: white; border-radius: 6px; border: 1px solid #dee2e6;">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 5px;">0-15초</div>
                                <div style="font-size: 24px; font-weight: bold; color: #007bff;">${counts['0-15초']}</div>
                                <div style="font-size: 11px; color: #999; margin-top: 5px;">${intervalStats['0-15초'].join(', ') || '없음'}</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: white; border-radius: 6px; border: 1px solid #dee2e6;">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 5px;">15-30초</div>
                                <div style="font-size: 24px; font-weight: bold; color: #28a745;">${counts['15-30초']}</div>
                                <div style="font-size: 11px; color: #999; margin-top: 5px;">${intervalStats['15-30초'].join(', ') || '없음'}</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: white; border-radius: 6px; border: 1px solid #dee2e6;">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 5px;">30-45초</div>
                                <div style="font-size: 24px; font-weight: bold; color: #ffc107;">${counts['30-45초']}</div>
                                <div style="font-size: 11px; color: #999; margin-top: 5px;">${intervalStats['30-45초'].join(', ') || '없음'}</div>
                            </div>
                            <div style="text-align: center; padding: 15px; background: white; border-radius: 6px; border: 1px solid #dee2e6;">
                                <div style="font-size: 12px; color: #6c757d; margin-bottom: 5px;">45-60초</div>
                                <div style="font-size: 24px; font-weight: bold; color: #dc3545;">${counts['45-60초']}</div>
                                <div style="font-size: 11px; color: #999; margin-top: 5px;">${intervalStats['45-60초'].join(', ') || '없음'}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 20px; padding: 20px; background: ${totalScore >= 15 ? '#d4edda' : totalScore >= 10 ? '#fff3cd' : '#f8d7da'}; 
                                border: 1px solid ${totalScore >= 15 ? '#c3e6cb' : totalScore >= 10 ? '#ffeeba' : '#f5c6cb'};
                                color: ${totalScore >= 15 ? '#155724' : totalScore >= 10 ? '#856404' : '#721c24'};
                                border-radius: 8px;">
                        <h3 style="margin-bottom: 10px; font-size: 18px;">종합 해석</h3>
                        <p style="margin: 0; line-height: 1.8;">${interpretation}</p>
                    </div>
                    
                    <div style="margin-top: 25px; padding-top: 20px; border-top: 1px solid #dee2e6; text-align: center; color: #6c757d; font-size: 14px;">
                        <p>검사일시: ${new Date().toLocaleString('ko-KR')}</p>
                        <p>가중치 점수: ${weightedScore.toFixed(1)}점</p>
                        <p style="margin-top: 10px;">* 본 결과는 참고용이며, 정확한 진단을 위해서는 전문가의 상담이 필요합니다.</p>
                    </div>
                </div>
            `;
            
            // 결과 표시 - 직접 처리
            console.log('결과 HTML 생성 완료, 표시 시작');
            
            // 결과 섹션에 직접 HTML 삽입
            resultsSection.innerHTML = resultHTML;
            resultsSection.style.display = 'block';
            resultsSection.style.visibility = 'visible';
            
            // 스크롤
            setTimeout(() => {
                resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                console.log('결과 화면으로 스크롤 완료');
            }, 100);
            
            // 음성 안내
            speak("분석이 완료되었습니다. 결과를 확인해 주세요.");
        }
        
        // CFTSCORING 결과 표시 (기존 함수 제거)
        /*
            // CFTSCORING과 동일한 범주 체계 사용
            const CATEGORIES = {
                // 생물학적 분류
                MAMMAL: '포유류',
                BIRD: '조류',
                REPTILE: '파충류',
                AMPHIBIAN: '양서류',
                FISH: '어류',
                INSECT: '곤충',
                MOLLUSK: '연체동물',
                CRUSTACEAN: '갑각류',
                
                // 서식지별 분류
                AQUATIC: '수생동물',
                MARINE: '해양동물',
                FRESHWATER: '담수동물',
                AERIAL: '비행동물',
                
                // 인간과의 관계
                DOMESTIC: '가축',
                PET: '애완동물',
                WILD: '야생동물',
                
                // 문화적 분류
                ZODIAC: '12간지',
                MYTHOLOGY: '신화동물',
                IMAGINARY: '상상의 동물',
                PREHISTORIC: '선사시대 동물'
            };
            
            // 간단한 동물 데이터베이스 (주요 동물만 포함)
            const ANIMAL_DATA = {
                '개': { MAMMAL: true, DOMESTIC: true, PET: true, ZODIAC: true },
                '고양이': { MAMMAL: true, DOMESTIC: true, PET: true },
                '소': { MAMMAL: true, DOMESTIC: true, ZODIAC: true },
                '말': { MAMMAL: true, DOMESTIC: true, ZODIAC: true },
                '돼지': { MAMMAL: true, DOMESTIC: true, ZODIAC: true },
                '양': { MAMMAL: true, DOMESTIC: true, ZODIAC: true },
                '염소': { MAMMAL: true, DOMESTIC: true, ZODIAC: true },
                '토끼': { MAMMAL: true, DOMESTIC: true, PET: true, ZODIAC: true },
                '호랑이': { MAMMAL: true, WILD: true, ZODIAC: true },
                '사자': { MAMMAL: true, WILD: true },
                '코끼리': { MAMMAL: true, WILD: true },
                '기린': { MAMMAL: true, WILD: true },
                '곰': { MAMMAL: true, WILD: true },
                '늑대': { MAMMAL: true, WILD: true },
                '여우': { MAMMAL: true, WILD: true },
                '원숭이': { MAMMAL: true, WILD: true, ZODIAC: true },
                '쥐': { MAMMAL: true, WILD: true, ZODIAC: true },
                '닭': { BIRD: true, DOMESTIC: true, ZODIAC: true },
                '오리': { BIRD: true, DOMESTIC: true, AQUATIC: true },
                '거위': { BIRD: true, DOMESTIC: true },
                '참새': { BIRD: true, WILD: true, AERIAL: true },
                '비둘기': { BIRD: true, WILD: true, AERIAL: true },
                '독수리': { BIRD: true, WILD: true, AERIAL: true },
                '뱀': { REPTILE: true, WILD: true, ZODIAC: true },
                '거북이': { REPTILE: true, PET: true, AQUATIC: true },
                '악어': { REPTILE: true, WILD: true, AQUATIC: true },
                '개구리': { AMPHIBIAN: true, WILD: true, AQUATIC: true },
                '두꺼비': { AMPHIBIAN: true, WILD: true },
                '물고기': { FISH: true, AQUATIC: true },
                '상어': { FISH: true, MARINE: true, WILD: true },
                '고래': { MAMMAL: true, MARINE: true, WILD: true },
                '돌고래': { MAMMAL: true, MARINE: true, WILD: true },
                '문어': { MOLLUSK: true, MARINE: true },
                '오징어': { MOLLUSK: true, MARINE: true },
                '새우': { CRUSTACEAN: true, MARINE: true },
                '게': { CRUSTACEAN: true, MARINE: true },
                '나비': { INSECT: true, AERIAL: true },
                '벌': { INSECT: true, AERIAL: true },
                '개미': { INSECT: true, WILD: true },
                '용': { ZODIAC: true, MYTHOLOGY: true, IMAGINARY: true, AERIAL: true }
            };
            
            // 클러스터 생성
            const clusters = [];
            let currentCluster = null;
            let lastCategories = [];
            
            animals.forEach((animal, index) => {
                // 현재 동물의 데이터 가져오기
                const animalData = ANIMAL_DATA[animal] || {};
                const animalCategories = [];
                
                // 현재 동물이 속한 범주들 찾기
                for (let [categoryKey, hasCategory] of Object.entries(animalData)) {
                    if (hasCategory === true) {
                        animalCategories.push(categoryKey);
                    }
                }
                
                // 이전 클러스터와 공유 범주가 있는지 확인
                const hasSharedCategory = lastCategories.some(cat => animalCategories.includes(cat));
                
                if (hasSharedCategory && currentCluster) {
                    // 같은 클러스터에 추가
                    currentCluster.animals.push(animal);
                    currentCluster.size++;
                } else {
                    // 새로운 클러스터 시작
                    if (currentCluster) {
                        clusters.push(currentCluster);
                    }
                    currentCluster = {
                        animals: [animal],
                        size: 1,
                        categories: animalCategories
                    };
                }
                
                lastCategories = animalCategories;
            });
            
            // 마지막 클러스터 추가
            if (currentCluster) {
                clusters.push(currentCluster);
            }
            
            // 전환 횟수
            const switching = Math.max(0, clusters.length - 1);
            
            // 비효율전환 계산 (크기 1인 클러스터 다음의 전환)
            let hardSwitching = 0;
            for (let i = 0; i < clusters.length - 1; i++) {
                if (clusters[i].size === 1) {
                    // 다음 클러스터와 공유 범주가 없는지 확인
                    const currentCategories = clusters[i].categories;
                    const nextCategories = clusters[i + 1].categories;
                    const hasShared = currentCategories.some(cat => nextCategories.includes(cat));
                    if (!hasShared) {
                        hardSwitching++;
                    }
                }
            }
            
            // 클러스터 통계
            const numberOfClusters = clusters.length;
            const clusterSizes = clusters.map(c => c.size);
            const meanClusterSize = numberOfClusters > 0 ? 
                (clusterSizes.reduce((sum, size) => sum + size, 0) / numberOfClusters).toFixed(1) : '0.0';
            const maxClusterSize = Math.max(...clusterSizes, 0);
            
            return {
                numberOfClusters,
                meanClusterSize,
                maxClusterSize,
                switching,
                hardSwitching
            };
        */
        
        
        // CFTSCORING에서 받은 HTML 결과 표시
        function displayCFTSCORINGResult(htmlContent) {
            console.log('CFTSCORING 결과 HTML 표시');
            
            // 결과 섹션 초기화 및 HTML 표시
            resultsSection.innerHTML = '';
            
            // CFTSCORING 결과 컨테이너 생성
            const containerDiv = document.createElement('div');
            containerDiv.style.cssText = 'margin: 20px auto; max-width: 1200px; padding: 20px;';
            containerDiv.innerHTML = htmlContent;
            
            // 다시 검사하기 버튼 추가
            const buttonDiv = document.createElement('div');
            buttonDiv.style.cssText = 'text-align: center; margin-top: 30px; padding: 20px;';
            buttonDiv.innerHTML = '<button onclick="window.location.href = window.location.pathname" style="background-color: #007bff; color: white; border: none; padding: 12px 30px; font-size: 16px; border-radius: 5px; cursor: pointer;">다시 검사하기</button>';
            
            resultsSection.appendChild(containerDiv);
            resultsSection.appendChild(buttonDiv);
            resultsSection.style.display = 'block';
            
            // 스크롤
            containerDiv.scrollIntoView({ behavior: 'smooth' });
            
            // 음성 안내
            speak("분석이 완료되었습니다. 결과를 확인해 주세요.");
        }
        

        
        // 이벤트 리스너는 DOM 요소 초기화 후에 추가됨

        // 키보드 입력 관련 이벤트 리스너 제거됨

        // 음성 목록 로드
        function loadVoices() {
            return new Promise((resolve) => {
                if (window.speechSynthesis) {
                    let voices = window.speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        resolve(voices);
                    } else {
                        window.speechSynthesis.onvoiceschanged = () => {
                            voices = window.speechSynthesis.getVoices();
                            resolve(voices);
                        };
                    }
                } else {
                    resolve([]);
                }
            });
        }

        
        // 이벤트 리스너는 DOM 요소 초기화 후에 추가됨

        // 키보드 입력 관련 이벤트 리스너 제거됨

        // 음성 목록 로드
        function loadVoices() {
            return new Promise((resolve) => {
                if (window.speechSynthesis) {
                    let voices = window.speechSynthesis.getVoices();
                    if (voices.length > 0) {
                        resolve(voices);
                    } else {
                        window.speechSynthesis.onvoiceschanged = () => {
                            voices = window.speechSynthesis.getVoices();
                            resolve(voices);
                        };
                    }
                } else {
                    resolve([]);
                }
            });
        }

        // 마이크 권한 및 음성인식 준비 (권한 요청 없이)
        async function prepareMicrophoneAndRecognition() {
            console.log('마이크 권한 및 음성인식 준비');
            
            // 음성인식 초기화
            if (!recognition) {
                initializeSpeechRecognition();
            }
            
            // 마이크 권한 요청
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('마이크 권한 획득 성공');
                
                // 오디오 시각화를 위한 스트림 저장
                audioStream = stream;
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    
                    // 스트림 저장
                    audioStream = stream;
                }
                
                return true;
            } catch (error) {
                console.error('마이크 권한 획득 실패:', error);
                alert('마이크 권한이 필요합니다. 브라우저 설정에서 마이크 권한을 허용해주세요.');
                return false;
            }
        }

        // 자동 음성 시작 시도 함수
        async function tryAutoVoiceStart() {
            console.log('tryAutoVoiceStart 호출됨');
            
            // DOM 요소 초기화
            initializeDOMElements();
            
            // 음성인식 초기화만 하고 권한은 나중에 요청
            if (!recognition) {
                console.log('음성인식 초기화 시도');
                initializeSpeechRecognition();
            }
            
            // 간단한 테스트 오디오로 자동재생 가능 여부 확인
            const testAudio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAA==');
            testAudio.play().then(() => {
                console.log('자동재생 가능 - 자동으로 시작');
                // 버튼 숨기고 바로 시작
                document.getElementById('manualStartBtn').style.display = 'none';
                setTimeout(() => {
                    // 중복 호출 방지 - handleStartClick에서 이미 실행됨
                    // startInstructions();
                }, 1000);
            }).catch(error => {
                console.log('자동재생 차단됨 - 시작 버튼 표시');
                // 시작 버튼은 이미 표시되어 있음
                // 사용자가 버튼을 클릭하면 handleStartClick이 호출됨
            });
        }

        // 페이지 로드 시 초기화
        window.addEventListener('load', async () => {
            // DOM 요소 초기화
            initializeDOMElements();
            
            // 이벤트 리스너 추가
            if (startBtn) startBtn.addEventListener('click', () => startTest());
            if (stopBtn) stopBtn.addEventListener('click', stopTest);
            if (resetBtn) resetBtn.addEventListener('click', resetTest);
            if (downloadBtn) downloadBtn.addEventListener('click', downloadResults);
            
            // 음성 목록 먼저 로드
            const voices = loadVoices();
            console.log('로드된 음성 목록:', voices.length, '개');
            
            // 하드웨어 설정 확인
            const hasSettings = loadHardwareSettings();
            
            if (!hasSettings) {
                console.log('하드웨어 설정이 없습니다. 기본 설정으로 진행합니다.');
                // 설정이 없어도 기본값으로 진행
                setupWarning.style.display = 'none';
            } else {
                console.log('하드웨어 설정을 성공적으로 불러왔습니다.');
                setupWarning.style.display = 'none';
            }
            
            // DOM 요소 확인
            console.log('DOM 요소 확인:', {
                manualStartBtn: document.getElementById('manualStartBtn'),
                readyBox: document.getElementById('readyBox'),
                testPage: document.getElementById('testPage')
            });
            
            // 시작 버튼에 이벤트 리스너 추가
            const manualStartBtn = document.getElementById('manualStartBtn');
            if (manualStartBtn) {
                console.log('시작 버튼에 이벤트 리스너 추가');
                console.log('시작 버튼 스타일:', {
                    display: window.getComputedStyle(manualStartBtn).display,
                    visibility: window.getComputedStyle(manualStartBtn).visibility,
                    opacity: window.getComputedStyle(manualStartBtn).opacity,
                    zIndex: window.getComputedStyle(manualStartBtn).zIndex
                });
                
                // 강제로 버튼을 보이도록 설정
                manualStartBtn.style.display = 'inline-block';
                manualStartBtn.style.visibility = 'visible';
                manualStartBtn.style.opacity = '1';
                manualStartBtn.style.position = 'relative';
                manualStartBtn.style.zIndex = '99999';
                
                console.log('시작 버튼 강제 표시 완료');
                
                manualStartBtn.addEventListener('click', function() {
                    console.log('시작 버튼 클릭됨!');
                    if (!isStartClicked) {
                        window.handleStartClick();
                    }
                });
            } else {
                console.error('manualStartBtn을 찾을 수 없습니다');
            }
            
            // 중복 제거됨 - 위에서 이미 처리
            
            // 사용자 정보 페이지 이벤트 리스너 추가
            const userInfoPrevBtn = document.getElementById('userInfoPrevBtn');
            const userInfoNextBtn = document.getElementById('userInfoNextBtn');
            const participantIdInput = document.getElementById('participantId');
            const userAgeInput = document.getElementById('userAge');
            const userEducationInput = document.getElementById('userEducation');
            
            
            if (userInfoNextBtn) {
                userInfoNextBtn.addEventListener('click', () => {
                    // 입력값 검증
                    if (!participantIdInput.value.trim()) {
                        alert('참가자 ID를 입력해주세요.');
                        participantIdInput.focus();
                        return;
                    }
                    if (!userAgeInput.value || userAgeInput.value < 1 || userAgeInput.value > 120) {
                        alert('올바른 연령을 입력해주세요.');
                        userAgeInput.focus();
                        return;
                    }
                    if (!userEducationInput.value || userEducationInput.value < 0 || userEducationInput.value > 30) {
                        alert('올바른 교육년수를 입력해주세요.');
                        userEducationInput.focus();
                        return;
                    }
                    
                    // 라디오 버튼 선택 검증
                    const selectedGender = document.querySelector('input[name="gender"]:checked');
                    if (!selectedGender) {
                        alert('성별을 선택해주세요.');
                        return;
                    }
                    
                    // 사용자 정보 저장
                    userInfo.participantId = participantIdInput.value.trim();
                    userInfo.age = userAgeInput.value;
                    userInfo.gender = selectedGender.value;
                    userInfo.education = userEducationInput.value;
                    
                    console.log('사용자 정보 저장됨:', userInfo);
                    
                    // 검사 페이지로 이동 후 바로 검사 시작
                    showPage('testPage');
                    
                    // 짧은 딜레이 후 자동으로 검사 시작
                    setTimeout(() => {
                        if (window.handleStartClick) {
                            console.log('자동으로 검사 시작');
                            window.handleStartClick();
                        }
                    }, 500);
                });
            }
            
            // 바로 사용자 정보 페이지로 이동
            showPage('userInfoPage');
            
            
            // 브라우저 체크
            const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
            const isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
            const isEdge = /Edg/.test(navigator.userAgent);
            
            if (!isChrome && (isSafari || isEdge)) {
                // Chrome이 아닌 경우 경고 표시
                document.getElementById('browserWarning').style.display = 'block';
            } else {
                // Chrome인 경우 1초 후 자동 음성 시작 시도
                setTimeout(() => {
                    tryAutoVoiceStart();
                }, 1000);
            }
        });
        
        // 분석 과정 보기 함수
        window.showAnalysisDetails = function() {
            // 결과 섹션 숨기기
            if (resultsSection) {
                resultsSection.style.display = 'none';
            }
            
            // 분석 과정 섹션 표시
            const analysisSection = document.getElementById('analysisDetailsSection');
            if (!analysisSection) {
                // 분석 과정 섹션 생성
                const section = document.createElement('div');
                section.id = 'analysisDetailsSection';
                section.style.cssText = 'background: rgba(255, 255, 255, 0.95); padding: 30px; border-radius: 10px; margin-top: 20px;';
                section.innerHTML = `
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <div style="text-align: right; margin-bottom: 20px;">
                            <button onclick="backToResults()" style="background-color: #1976d2; color: white; border: none; padding: 10px 25px; font-size: 14px; border-radius: 8px; cursor: pointer;">
                                결과로 돌아가기
                            </button>
                        </div>
                        
                        <h2 style="text-align: center; color: #333; margin-bottom: 30px;">분석 과정 상세</h2>
                        
                        <div id="analysisContent">
                            ${generateAnalysisProcessDetail()}
                        </div>
                    </div>
                `;
                // 최상단에 배치
                document.body.insertBefore(section, document.body.firstChild);
            } else {
                analysisSection.style.display = 'block';
                // 분석 내용 업데이트
                const analysisContent = document.getElementById('analysisContent');
                if (analysisContent) {
                    analysisContent.innerHTML = generateAnalysisProcessDetail();
                }
            }
            
            // 상단으로 스크롤
            window.scrollTo(0, 0);
        };
        
        // 결과로 돌아가기 함수
        window.backToResults = function() {
            // 분석 과정 섹션 숨기기
            const analysisSection = document.getElementById('analysisDetailsSection');
            if (analysisSection) {
                analysisSection.style.display = 'none';
            }
            
            // 결과 섹션 표시
            if (resultsSection) {
                resultsSection.style.display = 'block';
                resultsSection.scrollIntoView({ behavior: 'smooth' });
            }
        };
        
        // 분석 과정 상세 내용 생성 함수 - CFTSCORING과 동일
        window.generateAnalysisProcessDetail = function() {
            console.log('generateAnalysisProcessDetail 호출됨');
            console.log('animals 배열:', animals);
            console.log('animals 길이:', animals.length);
            
            if (!animals || animals.length === 0) {
                return '<div style="text-align: center; padding: 50px; color: #666;">분석할 데이터가 없습니다.</div>';
            }
            
            // CFTSCORING 형식의 responses 배열 생성
            const allResponses = animals.map((animal, idx) => {
                const timeSeconds = (animal.timestamp - startTime) / 1000;
                const timeRange = timeSeconds < 15 ? '0-15' :
                                timeSeconds < 30 ? '15-30' :
                                timeSeconds < 45 ? '30-45' : '45-60';
                
                return {
                    response: animal.name,
                    originalResponse: animal.name,
                    normalizedResponse: animal.isAnimal ? (animal.baseAnimal || normalizeAnimalName(animal.name) || animal.name) : null,
                    timeRange: timeRange,
                    timestamp: animal.timestamp
                };
            });
            
            // 전환 분석 실행
            const validResponses = allResponses.filter(r => r.normalizedResponse !== null);
            const { transitions, clusters, switchingScore, inefficientSwitchingScore } = analyzeTransitionsAndClusters(validResponses);
            
            let html = '<div style="font-size: 14px; line-height: 1.8;">';
            
            // 단어별 범주 판정 과정 테이블 (CFTSCORING과 동일)
            html += `<table class="detail-table" style="margin-bottom: 20px; width: 100%; background: #fff; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                <thead>
                    <tr>
                        <th>순서</th>
                        <th>시간대</th>
                        <th>단어</th>
                        <th>반응유형</th>
                        <th>보유 범주</th>
                        <th>클러스터 공통범주</th>
                        <th>겹치는 범주</th>
                        <th>판정</th>
                        <th>클러스터</th>
                    </tr>
                </thead>
                <tbody>`;
            
            // 모든 반응에 대한 상세 분석 정보 생성
            let currentClusterIdx = 0;
            let processedAnimals = 0;
            const seenAnimals = {};
            
            allResponses.forEach((response, idx) => {
                const animal = response.normalizedResponse;
                const originalAnimal = response.originalResponse || response.response;
                
                // 시간대 매핑
                const timeRange = response.timeRange || '';
                const timeRangeDisplay = timeRange === '0-15' ? '0-15초' :
                                       timeRange === '15-30' ? '15-30초' :
                                       timeRange === '30-45' ? '30-45초' :
                                       timeRange === '45-60' ? '45-60초' : '';
                
                // 반응유형 판정
                let responseType = '';
                let rowColor = '#f0f0f0';
                
                if (animal === null) {
                    // 침투반응
                    responseType = '<span style="color: #f44336; font-weight: bold;">침투</span>';
                    rowColor = '#ffebee';
                    
                    html += `<tr style="background-color: ${rowColor};">
                        <td style="text-align: center;">${idx + 1}</td>
                        <td style="text-align: center;">${timeRangeDisplay}</td>
                        <td><strong>${originalAnimal}</strong></td>
                        <td style="text-align: center;">${responseType}</td>
                        <td colspan="5" style="text-align: center; color: #999;">동물이 아님</td>
                    </tr>`;
                    return;
                }
                
                // 보속반응 체크
                seenAnimals[animal] = (seenAnimals[animal] || 0) + 1;
                if (seenAnimals[animal] > 1) {
                    responseType = '<span style="color: #ff9800; font-weight: bold;">보속</span>';
                    rowColor = '#fff3e0';
                    
                    html += `<tr style="background-color: ${rowColor};">
                        <td style="text-align: center;">${idx + 1}</td>
                        <td style="text-align: center;">${timeRangeDisplay}</td>
                        <td><strong>${animal}</strong></td>
                        <td style="text-align: center;">${responseType}</td>
                        <td colspan="5" style="text-align: center; color: #999;">중복 반응 (${seenAnimals[animal]}번째)</td>
                    </tr>`;
                    return;
                }
                
                // 정반응 처리
                responseType = '<span style="color: #4caf50;">정반응</span>';
                rowColor = '#f0f0f0';
                processedAnimals++;
                
                const animalData = ANIMAL_CATEGORIES[animal] || {};
                const categories = [];
                for (const [cat, value] of Object.entries(animalData)) {
                    if (value === true) categories.push(cat);
                }
                
                // 현재 동물이 속한 클러스터 찾기
                let belongsToCluster = null;
                let clusterCommonCategories = [];
                let overlappingCategories = [];
                let decision = '';
                
                // 처리된 정반응 인덱스 기준으로 클러스터 찾기
                let validAnimalIdx = processedAnimals - 1;
                
                for (let i = 0; i < clusters.length; i++) {
                    const cluster = clusters[i];
                    if (cluster.animals.includes(animal)) {
                        belongsToCluster = i + 1;
                        clusterCommonCategories = cluster.commonCategories;
                        
                        // 이전 정반응 동물과의 관계 확인
                        if (validAnimalIdx > 0 && i === currentClusterIdx) {
                            // 같은 클러스터 유지
                            overlappingCategories = categories.filter(cat => 
                                clusterCommonCategories.includes(cat)
                            );
                            decision = '유지';
                        } else if (validAnimalIdx > 0 && i !== currentClusterIdx) {
                            // 전환 발생
                            decision = '전환';
                            currentClusterIdx = i;
                        } else if (validAnimalIdx === 0) {
                            // 첫 정반응 동물
                            decision = '시작';
                            currentClusterIdx = i;
                            overlappingCategories = categories;
                        }
                        break;
                    }
                }
                
                // 전환 판정에 따른 행 색상
                if (decision === '전환') {
                    rowColor = '#ffe0e0';
                } else if (decision === '시작') {
                    rowColor = '#e0ffe0';
                }
                
                html += `<tr style="background-color: ${rowColor};">
                    <td style="text-align: center;">${idx + 1}</td>
                    <td style="text-align: center;">${timeRangeDisplay}</td>
                    <td><strong>${animal}</strong></td>
                    <td style="text-align: center;">${responseType}</td>
                    <td>${categories.map(c => CATEGORIES[c]).join(', ')}</td>
                    <td>${clusterCommonCategories.map(c => CATEGORIES[c]).join(', ') || '-'}</td>
                    <td>${overlappingCategories.map(c => CATEGORIES[c]).join(', ') || '없음'}</td>
                    <td style="text-align: center; font-weight: bold; color: ${decision === '전환' ? '#d32f2f' : decision === '시작' ? '#4caf50' : '#2196f3'};">
                        ${decision}
                        ${decision === '전환' && clusters[currentClusterIdx-1]?.size === 1 ? 
                          '<span style="background: #ffeb3b; padding: 2px 6px; border-radius: 3px; color: #333; font-size: 11px; margin-left: 5px;">비효율</span>' : ''}
                    </td>
                    <td style="text-align: center;">클러스터 ${belongsToCluster}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            
            html += '</div>';
            return html;
        }
    </script>
    </div> <!-- container 닫기 -->
</body>
</html>